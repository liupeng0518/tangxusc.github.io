<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Redis on 苏连云的博客</title>
    <link>https://tangxusc.github.io/blog/tags/redis/</link>
    <description>Recent content in Redis on 苏连云的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 20 Mar 2019 14:15:59 +0800</lastBuildDate>
    
	<atom:link href="https://tangxusc.github.io/blog/tags/redis/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>redis配置详解</title>
      <link>https://tangxusc.github.io/blog/2019/03/redis%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 20 Mar 2019 14:15:59 +0800</pubDate>
      
      <guid>https://tangxusc.github.io/blog/2019/03/redis%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid>
      <description>#redis.conf # Redis configuration file example. # ./redis-server /path/to/redis.conf ################################## INCLUDES ################################### #这在你有标准配置模板但是每个redis服务器又需要个性设置的时候很有用。 # include /path/to/local.conf # include /path/to/other.conf ################################ GENERAL ##################################### #是否在后台执行，yes：后台运行；no：不是后台运行（老版本默认） daemonize yes #3.2里的参数，是否开启保护模式，默认开启。要是配置里没有指定bind和密码。开启该参数后，redis只会本地进行访问，拒绝外部访问。要是开启了密码 和bind，可以开启。否 则最好关闭，设置为no。 protected-mode yes #redis的进程文件 pidfile /var/run/redis/redis-server.pid #redis监听的端口号。 port 6379 #此参数确定了TCP连接中已完成队列(完成三次握手之后)的长度， 当然此值必须不大于Linux系统定义的/proc/sys/net/core/somaxconn值，默认是511，而Linux的默认参数值是128。当系统并发量大并且客户端速度缓慢的时候，可以将这二个参数一起参考设定。该内核参数默认值一般是128，对于负载很大的服务程序来说大大的不够。一般会将它修改为2048或者更大。在/etc/sysctl.conf中添加:net.core.somaxconn = 2048，然后在终端中执行sysctl -p。 tcp-backlog 511 #指定 redis 只接收来自于该 IP 地址的请求，如果不进行设置，那么将处理所有请求 bind 127.0.0.1 #配置unix socket来让redis支持监听本地连接。 # unixsocket /var/run/redis/redis.sock #配置unix socket使用文件的权限 # unixsocketperm 700 # 此参数为设置客户端空闲超过timeout，服务端会断开连接，为0则服务端不会主动断开连接，不能小于0。 timeout 0 #tcp keepalive参数。如果设置不为0，就使用配置tcp的SO_KEEPALIVE值，使用keepalive有两个好处:检测挂掉的对端。降低中间设备出问题而导致网络看似连接却已经与对端端口的问题。在Linux内核中，设置了keepalive，redis会定时给对端发送ack。检测到对端关闭需要两倍的设置值。 tcp-keepalive 0 #指定了服务端日志的级别。级别包括：debug（很多信息，方便开发、测试），verbose（许多有用的信息，但是没有debug级别信息多），notice（适当的日志级别，适合生产环境），warn（只有非常重要的信息） loglevel notice #指定了记录日志的文件。空字符串的话，日志会打印到标准输出设备。后台运行的redis标准输出是/dev/null。 logfile /var/log/redis/redis-server.</description>
    </item>
    
    <item>
      <title>配置redis外网可访问</title>
      <link>https://tangxusc.github.io/blog/2019/03/%E9%85%8D%E7%BD%AEredis%E5%A4%96%E7%BD%91%E5%8F%AF%E8%AE%BF%E9%97%AE/</link>
      <pubDate>Wed, 20 Mar 2019 14:15:59 +0800</pubDate>
      
      <guid>https://tangxusc.github.io/blog/2019/03/%E9%85%8D%E7%BD%AEredis%E5%A4%96%E7%BD%91%E5%8F%AF%E8%AE%BF%E9%97%AE/</guid>
      <description>本文由 简悦 SimpRead 转码， 原文地址 https://blog.csdn.net/hel12he/article/details/46911159
 环境描述 在 Linux 中安装了 redis 服务
在 Windows 中安装了 xampp 环境。以供 PHP 运行
PHP 代码如下：
&amp;lt;?php $redis = new Redis(); $redis-&amp;gt;connect(&#39;192.168.1.4&#39;, 6379); $redis-&amp;gt;set(&#39;tag&#39;, &#39;hello&#39;); echo &#39;name:&#39;, $redis-&amp;gt;get(&#39;tag&#39;);  执行以上代码时，报错如下：
 Fatal error: Uncaught exception ‘RedisException’ with message ‘Redis server went away’ in xxxx
RedisException: Redis server went away in xxxxxx
 解错误分析及解决办法 错误的原因很简单，就是没有连接上 redis 服务，由于 redis 采用的安全策略，默认会只准许本地访问。需要通过简单配置，完成允许外网访问。
 修改 redis 的配置文件，将所有 bind 信息全部屏蔽。</description>
    </item>
    
  </channel>
</rss>