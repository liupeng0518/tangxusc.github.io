<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ddd on 苏连云的博客</title>
    <link>https://tangxusc.github.io/blog/categories/ddd/</link>
    <description>Recent content in Ddd on 苏连云的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 20 Mar 2019 14:15:59 +0800</lastBuildDate>
    
	<atom:link href="https://tangxusc.github.io/blog/categories/ddd/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>分布式事务Saga模式</title>
      <link>https://tangxusc.github.io/blog/2019/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1saga%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 20 Mar 2019 14:15:59 +0800</pubDate>
      
      <guid>https://tangxusc.github.io/blog/2019/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1saga%E6%A8%A1%E5%BC%8F/</guid>
      <description>分布式事务Saga模式 两阶段提交2PC是分布式事务中最强大的事务类型之一，两段提交就是分两个阶段提交，第一阶段询问各个事务数据源是否准备好，第二阶段才真正将数据提交给事务数据源，当需要同时更新多个数据源实体时，例如确认订单并立即更新库存时，它非常有用。
但是，当您使用微服务时，情况会变得复杂。每个服务都拥有自己的数据库系统，每个服务不能再越过别的服务直接访问那个服务的数据库了。
比如服务A有自己的数据库O1，服务B有自己的数据库O2，服务B如果想同时更新数据库O1和O2，就不能越过服务B直接操作数据库O1，而两段提交正是适合这样的场合，服务B可以在一个JTA事务中同时调用数据库O1的XA数据源JNDI，再调用数据库O2的XA数据源JNDI，那么O1和O2的数据就会实现两段提交，O1数据库执行修改或插入操作后其实没有保存到数据库，只有等O2数据库执行修改或插入操作后，才在第二阶段提交确认保存，这个过程如果有任何出错，数据库O1和数据库O2如同没有执行修改或插入一样，两者数据状态是一致的。
因此，在微服务架构中，因为一个服务不能越过其他服务直接访问它们的数据库，两段提交可能不适用，当然EJB提供了基于容器的跨服务分布式事务，虽然听起来很容易，但是因为是同步操作，对网络硬件要求比较高，一旦发生事务出错，需要手工介入数据库进行强制回滚，如果跨N个服务调用出错，出错定位是非常困难的，很难判断问题出在哪个服务器或哪段通讯上，不可能进行时间和空间的同时定位。
基于以上原因，本文介绍Saga模式是一种分布式异步事务，一种最终一致性事务，是一种柔性事务，当然从传统ACID同步事务过渡到异步事务需要很多思维方式切换和步骤证明，可见本站其他文章，这里。
下面以电子商务案例说明Saga模式实现：
API网关 后面是四个微服务：OrderService(订购) StockService(库存) PaymentService(支付) 和DeliveryService(货运)
在这个例子中，我们不能将“下订单，向客户收费，更新库存”这几个动作放入一个ACID事务中。但是又必须一致地执行这整个流程，这就需要创建一个分布式事务。
我们都知道，实施分布式任务是多么困难，而且不幸的是，事务也不例外。处理瞬态状态，服务之间的最终一致性，隔离和回滚是应该在设计阶段考虑的情况。
幸运的是，我们已经为它提出了一些很好的模式，因为我们已经实施了二十多年的分布式事务。今天我想谈论的那个叫做Saga模式。
Saga是最着名的分布式事务模式之一。关于它的第一篇文章早在1987年就已经发表了， 从那以后它一直是一个受欢迎的解决方案。
Saga是一系列本地交易，每笔事务都会更新单个服务中的数据。第一个事务由系统外部请求启动，然后每个后续步骤由前一个事件完成而触发。
对于我们这个电子商务示例，非常高层次级的Saga设计实现如下所示：
现在有两种不同的方式来实现saga事务，最流行的两种方式是：
 事件/编排Choreography：没有中央协调器（没有单点风险）时，每个服务产生并聆听其他服务的事件，并决定是否应采取行动。
 命令/协调orchestrator：中央协调器负责集中处理事件的决策和业务逻辑排序。
  让我们对这两个实现进行更深入的了解，以了解它们的工作方式。
事件/编排Events/Choreography 在Events/Choreography方法中，第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件。
当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何Saga参与者听到都意味着事务结束。
让我们看看它在我们的电子商务示例中的外观：
步骤如下： 1. 订单服务保存新订单，将状态设置为pengding挂起状态，并发布名为ORDER_CREATED_EVENT的事件。
 支付服务监听ORDER_CREATED_EVENT，并公布事件BILLED_ORDER_EVENT。
 库存服务监听BILLED_ORDER_EVENT，更新库存，并发布ORDER_PREPARED_EVENT。
 货运服务监听ORDER_PREPARED_EVENT，然后交付产品。最后，它发布ORDER_DELIVERED_EVENT
 最后，订单服务侦听ORDER_DELIVERED_EVENT并设置订单的状态为concluded完成。
  在上面的情况下，如果需要跟踪订单的状态，订单服务可以简单地监听所有事件并更新其状态。 在这个案例中，除了订单服务以外的其他服务都是订单服务的子服务，也就是说，为完成一个订单服务，需要经过这些步骤，订单服务与这些服务是包含与被包含关系，因此，订单服务在业务上天然是一个协调器。
回滚分布式事务并不是免费的。通常情况下，您必须实施额外操作才能弥补以前所做的工作。
假设库存服务在事务过程中失败了。让我们看看回滚是什么样子的：
1.库存服务产生PRODUCT_OUT_OF_STOCK_EVENT ;
2.订购服务和支付服务会监听到上面库存服务的这一事件： 1. 支付服务会退款给客户。 2. 订单服务将订单状态设置为失败。
请注意，为每个事务定义一个公共共享ID非常重要，因此每当您抛出一个事件时，所有侦听器都可以立即知道它引用的是哪个事务。
saga事件/编排设计的优点和缺点 事件/编排是实现Saga模式的自然方式; 它很简单，容易理解，不需要太多的努力来构建，所有参与者都是松散耦合的，因为他们彼此之间没有直接的耦合。如果您的事务涉及2至4个步骤，则可能是非常合适的。
但是，如果您在事务中不断添加额外步骤，则此方法可能会很快变得混乱，因为很难跟踪哪些服务监听哪些事件。此外，它还可能在服务之间添加循环依赖，因为它们必须订阅彼此的事件。
最后，使用这种设计来实现测试将会非常棘手。为了模拟交易行为，您应该运行所有服务。
Saga的命令/协调模式 这里我们定义了一项新服务，全权负责告诉每个参与者该做什么以及什么时候该做什么。saga协调器orchestrator以命令/回复的方式与每项服务进行通信，告诉他们应该执行哪些操作。
 订单服务保存pending状态，并要求订单Saga协调器（简称OSO）开始启动订单事务。
 OSO向收款服务发送执行收款命令，收款服务回复Payment Executed消息
 OSO向库存服务发送准备订单命令，库存服务将回复OrderPrepared消息</description>
    </item>
    
    <item>
      <title>如何一步一步用 DDD 设计一个电商网站</title>
      <link>https://tangxusc.github.io/blog/2019/03/%E5%A6%82%E4%BD%95%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E7%94%A8-ddd-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99/</link>
      <pubDate>Wed, 20 Mar 2019 14:15:59 +0800</pubDate>
      
      <guid>https://tangxusc.github.io/blog/2019/03/%E5%A6%82%E4%BD%95%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E7%94%A8-ddd-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99/</guid>
      <description> 本文由 简悦 SimpRead 转码， 原文地址 http://www.cnblogs.com/Zachary-Fan/p/5991674.html
 本系列所有文章
如何一步一步用 DDD 设计一个电商网站（一）—— 先理解核心概念
如何一步一步用 DDD 设计一个电商网站（二）—— 项目架构
如何一步一步用 DDD 设计一个电商网站（三）—— 初涉核心域
如何一步一步用 DDD 设计一个电商网站（四）—— 把商品卖给用户
如何一步一步用 DDD 设计一个电商网站（五）—— 停下脚步，重新出发
如何一步一步用 DDD 设计一个电商网站（六）—— 给购物车加点料，集成售价上下文
如何一步一步用 DDD 设计一个电商网站（七）—— 实现售价上下文
如何一步一步用 DDD 设计一个电商网站（八）—— 会员价的集成
如何一步一步用 DDD 设计一个电商网站（九）—— 小心陷入值对象持久化的坑
如何一步一步用 DDD 设计一个电商网站（十）—— 一个完整的购物车
如何一步一步用 DDD 设计一个电商网站（十一）—— 最后的准备
如何一步一步用 DDD 设计一个电商网站（十二）—— 提交并生成订单
如何一步一步用 DDD 设计一个电商网站（十三）—— 领域事件扩展
 本文只是收集 如何一步一步用 DDD 设计一个电商网站,作为索引使用
~!~
 </description>
    </item>
    
    <item>
      <title>微服务分布式事务Saga模式简介</title>
      <link>https://tangxusc.github.io/blog/2019/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1saga%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Wed, 20 Mar 2019 14:15:59 +0800</pubDate>
      
      <guid>https://tangxusc.github.io/blog/2019/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1saga%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/</guid>
      <description>该文是基于《微服务模式》作者Chris Richardson的QCONSF 2017会议上的PPT文章(这里)和其 Eventuate Tram Saga框架之上，对Saga模式进行的原理性解说，其中包含banq个人经验总结和见解，请从批判性视角看待。Chris Richardson的另外一本书籍《POJO in Action》曾经是帮助Spring成功挑战了EJB2。
在微服务环境下为什么不能使用ACID事务？因为每个微服务都拥有自己的私有数据库，比如订单服务有自己的订单数据库，而客户服务有自己的客户数据库，如果有一个业务操作需要跨订单和客户一起操作，那么一般使用JTA+XA方式跨订单数据库和客户数据库操作：
@ Transactional //事务元注解 public void crossAction(XX){ //事务开始 //这里ORDERS是属于订单服务的私有数据库 SELECT ORDER_TOTAL FROM ORDERS WHERE CUSTOMER_ID = ? //这里CUSTOMERS是属于客户服务的私有数据库 SELECT CREDIT_LIMIT FROM CUSTOMERS WHERE CUSTOMER_ID=? INERT INTO ORDERS ..... //提交事务 }  以上JTA操作如果结合XA数据源配置，将会实现2PC两段事务提交。
通过这段事务操作主要目的是为了维持业务上的不变性约束，比如一个人下订单的总金额不能超过这个人的信用卡授信额度，也就是说：一个人购买的商品总金额只能小于或等于他的信用卡授信额度。
但是，2PC两段提交并不是微服务分布式架构的选择，因为存在单点风险，因为锁也会降低吞吐量。分布式事务如果不结合CAP定理是无法认识清楚，2PC其实只是选择了CAP中CA，虽然CA保证了可靠性，但是忽视网络通讯随时可能堵塞或失败，形成网络分区，反而不可靠，2PC带来的可靠性在分布式环境中是虚幻的。
在分布式系统中，CAP定理是King，CAP定理无论是理论高度或是工程实施高度都是要高于传统事务的，在CAP定理的干预下，传统ACID事务走向了妥协，变成了BASE，也就是走向最终一致性的柔性事务。
Saga是来自于1987年Hector GM和Kenneth Salem论文，从原理上看Saga好像比较简单： 1. 客户端发出订单创建请求createOrder() 2. OrderService会在其内部本地事务进行Order数据库操作，此时订单状态是待确认状态。 3. CustomerService会在其内部本地事务进行信用卡预授权操作，检查订单金额是否超过信用卡授信额度？ 4. OrderService会在上一步确认业务不变性约束得到满足后，再次操作订单数据库状态，将订单状态改为确认状态。
但是，传统2PC/ACID事务中在上面任何一个步骤失败时会使用回滚操作，比如第三步出错，因为是两段提交，所以，第二段就不会进行确认提交，而是进行回滚Rollback，这样订单状态就恢复到当前事务之前的状态，但是在Saga这种BASE模式下,是无法实现像2PC回滚的，因为2PC是同步的，而Saga是异步的。
那么在Saga这种异步模式如何实现客户的及时响应呢？有两种可选方案：首先是当Saga流程全部完成时再发送响应，这样的好处是响应中带有处理结果，但是这样会降低可用性，CAP定理中，分布式环境中满足了C一致性，只能降低了可用性A。
第二种方案是推荐的，也就是在创建Saga之时，并不是等这个Saga流程完成时候，就发送响应给客户端，当然客户端可能只会得到一个事务ID号，并没有得到如期的处理结果，但是这样数据一致性比较弱的情况下，我们能获得很高的可用性A。
客户端可以根据事务ID号再次查询处理结果（通过浏览器异步调用或服务器端推送都可以），比如之前调用createOrder()，获得order的id，然后，根据这个id号调用getOrder(id)，这样就能获得自己创建的订单。在传统同步环境下，这两步其实是在同一个步骤实现的，也就是createOrder()的结果就是一个订单order。
通过UI界面设计可以降低这种不一致性导致的延迟体验： 1. UI会通过异步方式进行查询调用，给用户的体验感觉还是创建订单后返回了一个创建好的订单 2. Saga处理也是可以很快的，小于100毫秒。 3. 如果会花费很长时间，可以显示“正在处理中&amp;hellip;” 4. Saga处理完成后可以采取服务器推送结果到浏览器。
Saga是否实现了ACID？ ACID是原子性 一致性 隔离性和持久性的总称：</description>
    </item>
    
  </channel>
</rss>