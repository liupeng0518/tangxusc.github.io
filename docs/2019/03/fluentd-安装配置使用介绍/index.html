<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.55.0-DEV with theme Tranquilpeak 0.4.3-SNAPSHOT">
<meta name="author" content="苏连云">
<meta name="keywords" content="efk, fluentd">
<meta name="description" content="本文由 简悦 SimpRead 转码， 原文地址 https://blog.laisky.com/p/fluentd/
 fluentd 安装、配置、使用介绍  fluentd v1.0
 updated at 2016/10/8 updated at 2018/1/9: 完善内容 updated at 2018/1/23: 增加示例，更新为 v1.0 updated at 2018/4/9: 增加负载均衡 updated at 2018/4/25: 增加了负载均衡的一些实践细节   一、简介 fluentd2 是一个针对日志的收集、处理、转发系统。通过丰富的插件系统， 可以收集来自于各种系统或应用的日志，转化为用户指定的格式后，转发到用户所指定的日志存储系统之中。
通过 fluentd，你可以非常轻易的实现像追踪日志文件并将其过滤后转存到 MongoDB 这样的操作。fluentd 可以彻底的将你从繁琐的日志处理中解放出来。
用图来做说明的话，使用 fluentd 以前，你的系统是这样的：
使用了 fluentd 后，你的系统会成为这样：
（图片来源3）
此文将会对 fluentd 的安装、配置、使用等各方面做一个简要的介绍。
fluentd 既可以作为日志收集器安装到每一个结点上， 也可以作为一个服务端收集各个结点上报的日志流。 你甚至也可以在各个结点上都部署 fluentd 收集日志，然后上报到一个 fluentd 集群做统一处理， 然后再转发到最终的日志存储服务器。
所以在一个完整的日志收集、处理系统里，你可以构建一个这样的日志处理流：
Apps (with fluentd/fluent-bit) -&gt; broker (kafka) -&gt; fluentd cluster -&gt; elasticsearch -&gt; kibana  其中提到的 fluent-bit 是一个极简版的 fluentd，专门用作日志的收集和转发， 可以在应用结点上取代 fluentd 收集日志，满足极端的资源要求。">


<meta property="og:description" content="本文由 简悦 SimpRead 转码， 原文地址 https://blog.laisky.com/p/fluentd/
 fluentd 安装、配置、使用介绍  fluentd v1.0
 updated at 2016/10/8 updated at 2018/1/9: 完善内容 updated at 2018/1/23: 增加示例，更新为 v1.0 updated at 2018/4/9: 增加负载均衡 updated at 2018/4/25: 增加了负载均衡的一些实践细节   一、简介 fluentd2 是一个针对日志的收集、处理、转发系统。通过丰富的插件系统， 可以收集来自于各种系统或应用的日志，转化为用户指定的格式后，转发到用户所指定的日志存储系统之中。
通过 fluentd，你可以非常轻易的实现像追踪日志文件并将其过滤后转存到 MongoDB 这样的操作。fluentd 可以彻底的将你从繁琐的日志处理中解放出来。
用图来做说明的话，使用 fluentd 以前，你的系统是这样的：
使用了 fluentd 后，你的系统会成为这样：
（图片来源3）
此文将会对 fluentd 的安装、配置、使用等各方面做一个简要的介绍。
fluentd 既可以作为日志收集器安装到每一个结点上， 也可以作为一个服务端收集各个结点上报的日志流。 你甚至也可以在各个结点上都部署 fluentd 收集日志，然后上报到一个 fluentd 集群做统一处理， 然后再转发到最终的日志存储服务器。
所以在一个完整的日志收集、处理系统里，你可以构建一个这样的日志处理流：
Apps (with fluentd/fluent-bit) -&gt; broker (kafka) -&gt; fluentd cluster -&gt; elasticsearch -&gt; kibana  其中提到的 fluent-bit 是一个极简版的 fluentd，专门用作日志的收集和转发， 可以在应用结点上取代 fluentd 收集日志，满足极端的资源要求。">
<meta property="og:type" content="article">
<meta property="og:title" content="fluentd 安装、配置、使用介绍">
<meta name="twitter:title" content="fluentd 安装、配置、使用介绍">
<meta property="og:url" content="https://tangxusc.github.io/blog/2019/03/fluentd-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/">
<meta property="twitter:url" content="https://tangxusc.github.io/blog/2019/03/fluentd-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/">
<meta property="og:site_name" content="苏连云的博客">
<meta property="og:description" content="本文由 简悦 SimpRead 转码， 原文地址 https://blog.laisky.com/p/fluentd/
 fluentd 安装、配置、使用介绍  fluentd v1.0
 updated at 2016/10/8 updated at 2018/1/9: 完善内容 updated at 2018/1/23: 增加示例，更新为 v1.0 updated at 2018/4/9: 增加负载均衡 updated at 2018/4/25: 增加了负载均衡的一些实践细节   一、简介 fluentd2 是一个针对日志的收集、处理、转发系统。通过丰富的插件系统， 可以收集来自于各种系统或应用的日志，转化为用户指定的格式后，转发到用户所指定的日志存储系统之中。
通过 fluentd，你可以非常轻易的实现像追踪日志文件并将其过滤后转存到 MongoDB 这样的操作。fluentd 可以彻底的将你从繁琐的日志处理中解放出来。
用图来做说明的话，使用 fluentd 以前，你的系统是这样的：
使用了 fluentd 后，你的系统会成为这样：
（图片来源3）
此文将会对 fluentd 的安装、配置、使用等各方面做一个简要的介绍。
fluentd 既可以作为日志收集器安装到每一个结点上， 也可以作为一个服务端收集各个结点上报的日志流。 你甚至也可以在各个结点上都部署 fluentd 收集日志，然后上报到一个 fluentd 集群做统一处理， 然后再转发到最终的日志存储服务器。
所以在一个完整的日志收集、处理系统里，你可以构建一个这样的日志处理流：
Apps (with fluentd/fluent-bit) -&gt; broker (kafka) -&gt; fluentd cluster -&gt; elasticsearch -&gt; kibana  其中提到的 fluent-bit 是一个极简版的 fluentd，专门用作日志的收集和转发， 可以在应用结点上取代 fluentd 收集日志，满足极端的资源要求。">
<meta name="twitter:description" content="本文由 简悦 SimpRead 转码， 原文地址 https://blog.laisky.com/p/fluentd/
 fluentd 安装、配置、使用介绍  fluentd v1.0
 updated at 2016/10/8 updated at 2018/1/9: 完善内容 updated at 2018/1/23: 增加示例，更新为 v1.0 updated at 2018/4/9: 增加负载均衡 updated at 2018/4/25: 增加了负载均衡的一些实践细节   一、简介 fluentd2 是一个针对日志的收集、处理、转发系统。通过丰富的插件系统， 可以收集来自于各种系统或应用的日志，转化为用户指定的格式后，转发到用户所指定的日志存储系统之中。
通过 fluentd，你可以非常轻易的实现像追踪日志文件并将其过滤后转存到 MongoDB 这样的操作。fluentd 可以彻底的将你从繁琐的日志处理中解放出来。
用图来做说明的话，使用 fluentd 以前，你的系统是这样的：
使用了 fluentd 后，你的系统会成为这样：
（图片来源3）
此文将会对 fluentd 的安装、配置、使用等各方面做一个简要的介绍。
fluentd 既可以作为日志收集器安装到每一个结点上， 也可以作为一个服务端收集各个结点上报的日志流。 你甚至也可以在各个结点上都部署 fluentd 收集日志，然后上报到一个 fluentd 集群做统一处理， 然后再转发到最终的日志存储服务器。
所以在一个完整的日志收集、处理系统里，你可以构建一个这样的日志处理流：
Apps (with fluentd/fluent-bit) -&gt; broker (kafka) -&gt; fluentd cluster -&gt; elasticsearch -&gt; kibana  其中提到的 fluent-bit 是一个极简版的 fluentd，专门用作日志的收集和转发， 可以在应用结点上取代 fluentd 收集日志，满足极端的资源要求。">
<meta property="og:locale" content="en-us">

  
    <meta property="article:published_time" content="2019-03-20T14:15:59">
  
  
    <meta property="article:modified_time" content="2019-03-20T14:15:59">
  
  
  
    
      <meta property="article:section" content="efk">
    
      <meta property="article:section" content="fluentd">
    
  
  
    
      <meta property="article:tag" content="efk">
    
      <meta property="article:tag" content="fluentd">
    
  


<meta name="twitter:card" content="summary">











  <meta property="og:image" content="https://www.gravatar.com/avatar/a3d740bc2618da5f5a9de4fe94c05429?s=640">
  <meta property="twitter:image" content="https://www.gravatar.com/avatar/a3d740bc2618da5f5a9de4fe94c05429?s=640">


    <title>fluentd 安装、配置、使用介绍</title>

    <link rel="icon" href="https://tangxusc.github.io/blog/favicon.png">
    

    

    <link rel="canonical" href="https://tangxusc.github.io/blog/2019/03/fluentd-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="https://tangxusc.github.io/blog/css/style-nnm2spxvve8onlujjlegkkytaehyadd4ksxc1hyzzq9a2wvtrgbljqyulomn.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="4">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://tangxusc.github.io/blog/">苏连云的博客</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://tangxusc.github.io/blog/#about">
    
    
    
      
        <img class="header-picture" src="https://www.gravatar.com/avatar/a3d740bc2618da5f5a9de4fe94c05429?s=90" alt="Author&#39;s picture" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="4">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://tangxusc.github.io/blog/#about">
          <img class="sidebar-profile-picture" src="https://www.gravatar.com/avatar/a3d740bc2618da5f5a9de4fe94c05429?s=110" alt="Author&#39;s picture" />
        </a>
        <h4 class="sidebar-profile-name">苏连云</h4>
        
          <h5 class="sidebar-profile-bio">酒剑仙,醉仙酒</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://tangxusc.github.io/blog/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">Home</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://tangxusc.github.io/blog/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">Categories</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://tangxusc.github.io/blog/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">Tags</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://tangxusc.github.io/blog/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">Archives</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://tangxusc.github.io/blog/#about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">About</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/tangxusc/blog" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="4"
        class="
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      fluentd 安装、配置、使用介绍
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2019-03-20T14:15:59&#43;08:00">
        
  March 20, 2019

      </time>
    
    
  
  
    <span>in</span>
    
      <a class="category-link" href="https://tangxusc.github.io/blog/categories/efk">efk</a>, 
    
      <a class="category-link" href="https://tangxusc.github.io/blog/categories/fluentd">fluentd</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              

<blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://blog.laisky.com/p/fluentd/">https://blog.laisky.com/p/fluentd/</a></p>
</blockquote>

<h1 id="fluentd-安装-配置-使用介绍">fluentd 安装、配置、使用介绍</h1>

<blockquote>
<p>fluentd v1.0</p>

<ul>
<li>updated at 2016/10/8</li>
<li>updated at 2018/1/9: 完善内容</li>
<li>updated at 2018/1/23: 增加示例，更新为 v1.0</li>
<li>updated at 2018/4/9: 增加负载均衡</li>
<li>updated at 2018/4/25: 增加了负载均衡的一些实践细节</li>
</ul>
</blockquote>

<hr />

<h2 id="一-简介">一、简介</h2>

<p>fluentd<sup class="footnote-ref" id="fnref-home"><a href="#fn-home">2</a></sup> 是一个针对日志的收集、处理、转发系统。通过丰富的插件系统， 可以收集来自于各种系统或应用的日志，转化为用户指定的格式后，转发到用户所指定的日志存储系统之中。</p>

<p>通过 fluentd，你可以非常轻易的实现像追踪日志文件并将其过滤后转存到 MongoDB 这样的操作。fluentd 可以彻底的将你从繁琐的日志处理中解放出来。</p>

<p>用图来做说明的话，使用 fluentd 以前，你的系统是这样的：</p>

<p><img src="https://s1.laisky.com/images/fluentd-before.png" alt="null" /></p>

<p>使用了 fluentd 后，你的系统会成为这样：</p>

<p><img src="https://s1.laisky.com/images/fluentd-after.png" alt="null" /></p>

<p><em>（图片来源<sup class="footnote-ref" id="fnref-refer"><a href="#fn-refer">3</a></sup>）</em></p>

<p>此文将会对 fluentd 的安装、配置、使用等各方面做一个简要的介绍。</p>

<p>fluentd 既可以作为日志收集器安装到每一个结点上， 也可以作为一个服务端收集各个结点上报的日志流。 你甚至也可以在各个结点上都部署 fluentd 收集日志，然后上报到一个 fluentd 集群做统一处理， 然后再转发到最终的日志存储服务器。</p>

<p>所以在一个完整的日志收集、处理系统里，你可以构建一个这样的日志处理流：</p>

<pre><code>Apps (with fluentd/fluent-bit) -&gt; broker (kafka) -&gt; fluentd cluster -&gt; elasticsearch -&gt; kibana

</code></pre>

<p>其中提到的 fluent-bit 是一个极简版的 fluentd，专门用作日志的收集和转发， 可以在应用结点上取代 fluentd 收集日志，满足极端的资源要求。</p>

<h3 id="1-与-logstash-的对比">1、与 logstash 的对比</h3>

<p>通过上述描述，你也许会觉得和 ELK 中的 Logstash 高度相似。事实上也确实如此，你完全可以用 fluentd 来替换掉 ELK 中的 Logstash。</p>

<p>有两篇文章对这两个工具做了很好的对比：</p>

<ul>
<li><a href="https://logz.io/blog/fluentd-logstash/">Fluentd vs. Logstash: A Comparison of Log Collectors</a></li>
<li><a href="http://work.haufegroup.io/log-aggregation/">Log Aggregation with Fluentd, Elasticsearch and Kibana</a></li>
</ul>

<p>概括一下的话，有以下区别：</p>

<ul>
<li>fluentd 比 logstash 更省资源；</li>
<li>更轻量级的 fluent-bid 对应 filebeat，作为部署在结点上的日志收集器；</li>
<li>fluentd 有更多强大、开放的插件数量和社区。</li>
</ul>

<hr />

<h2 id="二-install">二、Install</h2>

<blockquote>
<p>2017 年 12 月的时候，fluentd 发布了 v1.0 版本，也就是 td-agent v3 版。</p>
</blockquote>

<p>从 gem 安装和从 rpm、yum 安装的名字不一样，连配置文件的路径都不一样，需要记住的是：</p>

<ul>
<li>从 gem 安装的，配置文件和执行程序都叫做 fluent；</li>
<li>从 rpm 安装的，配置文件和执行程序都叫做 td-agent3。</li>
</ul>

<p>td-agent 和 fluentd 是同一个软件，区别在于 td-agent 更注重于稳定性，在更新上会稍晚于 fluentd，而且依赖的一些库也会有不同（如 jemalloc），更适用于用于生产环境。</p>

<p><img src="https://s1.laisky.com/images/fluentd-tdagent.jpg" alt="fluentd-tdagent" /></p>

<h3 id="1-安装-fluentd">1、安装 fluentd</h3>

<p>详细可参见<a href="https://docs.fluentd.org/v1.0/articles/quickstart#step-1:-installing-fluentd">官方文档</a>。</p>

<p>以 CentOS 为例：</p>

<pre><code># 安装
$ curl -L https://toolbelt.treasuredata.com/sh/install-redhat-td-agent3.sh | sh

# 通过 systemd 启动
$ sudo systemctl start td-agent.service
$ sudo systemctl status td-agent.service

# 或者也可以手动启动
$ /etc/init.d/td-agent start
$ /etc/init.d/td-agent stop
$ /etc/init.d/td-agent restart
$ /etc/init.d/td-agent status

</code></pre>

<h3 id="2-安装插件">2、安装插件</h3>

<pre><code># 从 rpm 安装的话，
# 比如要使用下例的 mongo，需要安装
# $ sudo td-agent-gem install fluent-plugin-mongo
$ sudo td-agent-gem &lt;PLUGIN_NAME&gt;

# 从 gem 安装的话
$ sudo gem install &lt;PLUGIN_NAME&gt;

</code></pre>

<hr />

<h2 id="三-配置文件">三、配置文件</h2>

<h3 id="1-路径">1、路径</h3>

<p>分为两种情况：</p>

<ul>
<li><p>如果是通过 gem 安装的，那么可以通过下列命令生成和编辑配置文件</p>

<pre><code>$ sudo fluentd --setup /etc/fluent
$ sudo vi /etc/fluent/fluent.conf

</code></pre></li>

<li><p>如果是通过 RPM, Deb 或 DMG 安装的，那么配置文件在：</p>

<pre><code>$ sudo vi /etc/td-agent/td-agent.conf

</code></pre></li>
</ul>

<h3 id="2-重用">2、重用</h3>

<p>你可以在配置文件里使用 <code>@include</code> 来切分你的配置文件，include 支持多种写法：</p>

<pre><code># 绝对路径
include /path/to/config.conf
# 相对路径
@include conf.d/*.conf
# 甚至 URL
@include http://example.com/fluent.conf

</code></pre>

<h3 id="3-数据格式">3、数据格式</h3>

<p>在配置文件里你需要为很多参数赋值，这些值必须使用 fluentd 支持的数据格式，有下列这些：</p>

<ul>
<li><code>string</code>：字符串，最常见的格式，详细支持语法见文档<sup class="footnote-ref" id="fnref-literal"><a href="#fn-literal">1</a></sup>；</li>
<li><code>integer</code>：整数</li>
<li><code>float</code>：浮点数；</li>
<li><code>size</code> 大小，仅支持整数

<ul>
<li><code>&lt;INTEGER&gt;k</code> 或 <code>&lt;INTERGER&gt;K</code>；</li>
<li><code>&lt;INTEGER&gt;m</code> 或 <code>&lt;INTERGER&gt;M</code>；</li>
<li><code>&lt;INTEGER&gt;g</code> 或 <code>&lt;INTERGER&gt;G</code>；</li>
<li><code>&lt;INTEGER&gt;t</code> 或 <code>&lt;INTERGER&gt;T</code>。</li>
</ul></li>
<li><code>time</code>：时间，也只支持整数；

<ul>
<li><code>&lt;INTEGER&gt;s</code> 或 <code>&lt;INTERGER&gt;S</code>；</li>
<li><code>&lt;INTEGER&gt;m</code> 或 <code>&lt;INTERGER&gt;M</code>；</li>
<li><code>&lt;INTEGER&gt;h</code> 或 <code>&lt;INTERGER&gt;H</code>；</li>
<li><code>&lt;INTEGER&gt;d</code> 或 <code>&lt;INTERGER&gt;D</code>。</li>
</ul></li>
<li><code>array</code>：按照 JSON array 解析；</li>
<li><code>hash</code>：按照 JSON object 解析。</li>
</ul>

<hr />

<h2 id="四-命令">四、命令</h2>

<p>配置文件的核心是各种命令块(directives)，每一种命令都是为了完成某种处理，命令与命令之间还可以组成串联关系，以 pipline 的形式流式的处理和分发日志。</p>

<p>命令的主要组成部分有：</p>

<ul>
<li>source</li>
<li>filter</li>
<li>match</li>
<li>label</li>
<li>error</li>
</ul>

<p>最常见的方式就是 source 收集日志，然后由串联的 filter 做流式的处理，最后交给 match 进行分发。match 是日志流程的终点，一旦匹配了某一个 match，就不会再继续往下匹配了。</p>

<p>同时你还可以用 label 将任务分组，用 error 处理异常，用 system 修改运行参数。</p>

<p>不同的命令中，都可以通过 <code>@type</code> 指定想要使用的插件名字，而且还可以传入各式各样的插件参数， 由丰富的插件提供强大的功能，下面是详细一些的说明。（关于参数的说明在下面一章。）</p>

<h3 id="1-source">1、source</h3>

<p>source 是 fluentd 的一切数据的来源，每一个 source 内都包含一个输入模块，比如原生集成的包含 <code>http</code> 和 <code>forward</code> 两个模块，分别用来接收 HTTP 请求和 TCP 请求：</p>

<pre><code># Receive events from 24224/tcp
# This is used by log forwarding and the fluent-cat command
&lt;source&gt;
  @type forward
  port 24224
&lt;/source&gt;

# http://this.host:9880/myapp.access?json={&quot;event&quot;:&quot;data&quot;}
&lt;source&gt;
  @type http
  port 9880
&lt;/source&gt;

</code></pre>

<p>当然，除了这两个外，fluentd 还有大量的支持各种协议或方式的 source 插件，比如最常用的 <code>tail</code> 就可以帮你追踪文件。</p>

<p>每一个具体的插件都包含其特有的参数，比如上例中 <code>port</code> 就是一个参数，当你要使用一个 source 插件的时候，注意看看有哪些参数是需要配置的，然后将其写到 source directive 内。</p>

<p>source dirctive 在获取到输入后，会向 fluent 的路由抛出一个事件，这个事件包含三个要素：</p>

<ul>
<li>tag</li>
<li>time</li>
<li>record</li>
</ul>

<p>那上例代码中的第二个 source 举例，当我们发起一个 <code>http://this.host:9880/myapp.access?json={&quot;event&quot;:&quot;data&quot;}</code> 的请求时，这个 source 会抛出：</p>

<pre><code># generated by http://this.host:9880/myapp.access?json={&quot;event&quot;:&quot;data&quot;}
tag: myapp.access
time: (current time)
record: {&quot;event&quot;:&quot;data&quot;}

</code></pre>

<p>关于如何编写一个输入插件，可以参考文档<sup class="footnote-ref" id="fnref-input-plugin"><a href="#fn-input-plugin">4</a></sup>。</p>

<h3 id="2-match">2、match</h3>

<p>match 用来指定动作，通过 tag 匹配 source，然后执行指定的命令来分发日志，最常见的用法就是将 source 收集的日志转存到数据库。</p>

<pre><code># http://this.host:9880/myapp.access?json={&quot;event&quot;:&quot;data&quot;}
&lt;source&gt;
  @type http
  port 9880
&lt;/source&gt;

# 将标记为 myapp.access 的日志转存到文件
&lt;match myapp.access&gt;
  @type file
  path /var/log/fluent/access
&lt;/match&gt;

</code></pre>

<p>上例中的 <code>myapp.access</code> 就是 tag，tag 有好几种匹配模式：</p>

<ul>
<li><code>*</code>：匹配任意一个 tag；</li>
<li><code>**</code>：匹配任意数量个 tag；</li>
<li><code>a b</code>：匹配 a 或 b；</li>
<li><code>{X,Y,Z}</code>：匹配 X, Y, Z 中的一个。</li>
</ul>

<p>比如我可以写成这样：</p>

<pre><code>&lt;match a.*&gt;
&lt;match **&gt;
&lt;match a.{b,c}&gt;
&lt;match a.* b.*&gt;

</code></pre>

<p>match 是从上往下依次匹配的，一旦一个日志流被匹配上，就不会再继续匹配剩下的 match 了。 所以如果有 <code>&lt;match **&gt;</code> 这样的全匹配，一定要放到配置文件的最后。</p>

<p>用法和 source 几乎一模一样，不过 source 是抛出事件，match 是接收并处理事件。你同样可以找到大量的各式各样的输出插件，也可以参考文档<sup class="footnote-ref" id="fnref-output-plugin"><a href="#fn-output-plugin">5</a></sup>自己写一个。</p>

<p>而且 match 不仅仅用来处理输出，还可以对日志事件进行一些处理后重新抛出，当成一个新的事件从新走一遍流程，比如可以用 <code>rewrite_tag_filter</code> 插件为日志流重新打上 tag，实现通过正则来对日志进行分流的需求：</p>

<pre><code>&lt;match app&gt;
  # 捕获被打上了 app tag 的日志
  ...
&lt;/match&gt;

&lt;match cp&gt;
  # 捕获被打上了 cp tag 的日志
  ...
&lt;/match&gt;

&lt;match **&gt;
  # https://docs.fluentd.org/v0.12/articles/out_rewrite_tag_filter
  # 被打上 tag 的日志会被从头处理，从而被上面的 match 捕获，实现了日志的分流
  @type rewrite_tag_filter
  &lt;rule&gt;
    key log  # 指定要处理的 field
    pattern ^.*\ c\.p\.\ .*  # 匹配条件
    tag cp  # 打上 tag `cp`
  &lt;/rule&gt;
  &lt;rule&gt;
    key log
    pattern ^.*
    tag app  # 其余日志打上 tag `app`
  &lt;/rule&gt;
&lt;/match&gt;

</code></pre>

<h3 id="3-filter">3、filter</h3>

<p>filter 和 match 的语法几乎完全一样，但是 filter 可以串联成 pipeline，对数据进行串行处理，最终再交给 match 输出。</p>

<pre><code># http://this.host:9880/myapp.access?json={&quot;event&quot;:&quot;data&quot;}
&lt;source&gt;
  @type http
  port 9880
&lt;/source&gt;

&lt;filter myapp.access&gt;
  @type record_transformer
  &lt;record&gt;
    host_param &quot;#{Socket.gethostname}&quot;
  &lt;/record&gt;
&lt;/filter&gt;

&lt;match myapp.access&gt;
  @type file
  path /var/log/fluent/access
&lt;/match&gt;

</code></pre>

<p>这个例子里，filter 获取数据后，调用原生的 <code>@type record_transformer</code> 插件，在事件的 record 里插入了新的字段 <code>host_param</code>，然后再交给 match 输出。</p>

<p>你可以参考文档<sup class="footnote-ref" id="fnref-filter-plugin"><a href="#fn-filter-plugin">6</a></sup>来学习如何编写自定义的 filter。</p>

<h3 id="4-system">4、system</h3>

<p>fluentd 的相关设置，可以在启动时设置，也可以在配置文件里设置，包含：</p>

<ul>
<li><code>log_level</code></li>
<li><code>suppress_repeated_stacktrace</code></li>
<li><code>emit_error_log_interval</code></li>
<li><code>suppress_config_dump</code></li>
<li><code>without_source</code></li>
</ul>

<hr />

<h2 id="五-插件介绍-plugins">五、插件介绍 Plugins</h2>

<p>Fluentd 有一个非常活跃社区，提供了大量的插件，你可以在这里看到大多数常见插件的列表：<a href="https://www.fluentd.org/plugins/all">List of All Plugins</a>。</p>

<p>Fluentd 支持 7 种类型的插件：</p>

<ul>
<li><a href="https://docs.fluentd.org/v1.0/articles/input-plugin-overview">Input</a>：事件流入口；</li>
<li><a href="https://docs.fluentd.org/v1.0/articles/parser-plugin-overview">Parser</a>：修改 Input 插件中事件格式，用于 Source；</li>
<li><a href="https://docs.fluentd.org/v1.0/articles/filter-plugin-overview">Filter</a>： 修改事件流，用于 Filter；</li>
<li><a href="https://docs.fluentd.org/v1.0/articles/output-plugin-overview">Output</a>：输出插件，用于 Match；</li>
<li><a href="https://docs.fluentd.org/v1.0/articles/formatter-plugin-overview">Formatter</a>：修改 Output 插件中事件流的格式，用于 Match；</li>
<li><a href="https://docs.fluentd.org/v1.0/articles/buffer-plugin-overview">Buffer</a>：在 Output 插件中指定 buffer，用于 Match；</li>
<li><a href="https://docs.fluentd.org/v1.0/articles/storage-plugin-overview">Storage</a>：将插件状态存入内存或数据库，可用于 Source、Filter 和 Match，需要插件支持 storage 命令。</li>
</ul>

<hr />

<h2 id="六-插件参数-parameters">六、插件参数 Parameters</h2>

<p>不同的插件都可以设定不同的参数，拿最简单的 forward 举个例子：</p>

<pre><code>&lt;source&gt;
  @type http
  port 9880
&lt;/source&gt;

</code></pre>

<p>其中 <code>@type</code>、<code>port</code> 都是参数，一个指明了插件的名字，另一个指明了监听的端口。</p>

<p>fluentd 里有两种类型的参数：</p>

<ul>
<li>默认参数：以 <code>@</code> 开头的都是默认参数；</li>
<li>插件参数：其余的参数都是插件参数，为插件做配置，可以在插件文档里查阅。</li>
</ul>

<h3 id="1-默认参数-common-plugin-parameter">1、默认参数 Common plugin parameter</h3>

<p>fluentd 里只有四个默认参数：</p>

<ul>
<li><code>@type</code>：用于指定插件类型；</li>
<li><code>@id</code>：指定插件 id，在输出监控信息的时候有用；</li>
<li><code>@label</code>：指定分组标签，可以对日志流做批处理；</li>
<li><code>@log_level</code>：为每一组命令设定日志级别。</li>
</ul>

<h4 id="label">label</h4>

<p>label 用于将任务进行分组，方便复杂任务的管理。</p>

<p>你可以在 source 里指定 <code>@label @&lt;LABEL_NAME&gt;</code>， 这个 source 所触发的事件就会被发送给指定的 label 所包含的任务， 而不会被后续的其他任务获取到。</p>

<p>需要注意的是，label 一旦被声明了，就必须在后面被用到，否则会报错。</p>

<p>看个例子：</p>

<pre><code>&lt;source&gt;
  @type forward
&lt;/source&gt;

&lt;source&gt;
  # 这个任务指定了 label 为 @SYSTEM
  # 会被发送给 &lt;label @SYSTEM&gt;
  # 而不会被发送给下面紧跟的 filter 和 match
  @type tail
  @label @SYSTEM
&lt;/source&gt;

&lt;filter access.**&gt;
  @type record_transformer
  &lt;record&gt;
    # ...
  &lt;/record&gt;
&lt;/filter&gt;
&lt;match **&gt;
  @type elasticsearch
  # ...
&lt;/match&gt;

&lt;label @SYSTEM&gt;
  # 将会接收到上面 @type tail 的 source event
  &lt;filter var.log.middleware.**&gt;
    @type grep
    # ...
  &lt;/filter&gt;
  &lt;match **&gt;
    @type s3
    # ...
  &lt;/match&gt;
&lt;/label&gt;

</code></pre>

<h4 id="error">error</h4>

<p>用来接收插件通过调用 <code>emit_error_event</code> API 抛出的异常，使用方法和 label 一样，通过设定 <code>&lt;label @ERROR&gt;</code> 就可以接收到相关的异常。</p>

<h4 id="log-level">log_level</h4>

<blockquote>
<p><a href="https://docs.fluentd.org/v0.12/articles/logging#log-level">官方文档</a></p>
</blockquote>

<p>目前支持的日志级别参数值有：</p>

<ul>
<li><code>fatal</code></li>
<li><code>error</code></li>
<li><code>warn</code></li>
<li><code>info</code></li>
<li><code>debug</code></li>
<li><code>trace</code></li>
</ul>

<p>从上往下依次递减，当你指定了一个级别后，会捕获大于等于该级别的所有日志。</p>

<p>比如如果你指定 <code>@log_level info</code>，就会获取到 <code>info, warn, error, fatal</code> 级别的日志。</p>

<h3 id="2-其他插件参数">2、其他插件参数</h3>

<p>除了默认参数外，各个插件还可以定制自己的参数，这个就需要查阅你所用插件的文档页面了。</p>

<p>拿 <code>tail</code> 举个例子，我们可以查阅 <a href="https://docs.fluentd.org/v1.0/articles/in_tail#parameters">文档</a>， 可以看到它有 <code>tag, path, exclude_path, ...</code> 等一系列的参数，比如其中 <code>tag</code> 就可以为日志流打上供 <code>match</code> 使用的 <code>tag</code>。</p>

<hr />

<h2 id="七-高可用">七、高可用</h2>

<p>内容来源于官方文档：<a href="https://docs.fluentd.org/v1.0/articles/high-availability">Fluentd High Availability Configuration</a>。</p>

<h3 id="1-message-delivery-semantics">1、Message Delivery Semantics</h3>

<p>任何消息传递系统，都需要考虑消息递交语义（delivery semantics）：</p>

<ul>
<li>At most once：最多传递一次，有可能会丢消息，但是不会重复；</li>
<li>At least once：最少传递一次，不会丢消息，但是可能重复；</li>
<li>Exactly once：确切的只传递一次，需要多次确认消息状态，会极大的牺牲性能。</li>
</ul>

<p>一般来说，我们会根据业务场景，在前两种中选择一种，第三种因为性能较差，只适合在小型内部系统上玩玩。</p>

<h3 id="2-网络拓扑">2、网络拓扑</h3>

<p>一个日志收集系统由两个角色组成：</p>

<ul>
<li>log forwarders：负责日志采集和转发；</li>
<li>log aggregators：负责日志收集和汇总处理。</li>
</ul>

<p>fluentd 可以扮演上述两个角色（或者由 fluent-bit 扮演 forwarders 角色），为了保证高可用， 对 aggregators 做多点备份：</p>

<p><img src="https://s2.laisky.com/images/fluentd_ha.png" alt="fluentd-ha" /></p>

<p>我们需要在 log forwarders 里配置多个 aggregators：</p>

<pre><code># Log Forwarding
&lt;match mytag.**&gt;
  @type forward

  # 主 aggregator
  &lt;server&gt;
    host 192.168.0.1
    port 24224
  &lt;/server&gt;
  # 备用 aggregators
  &lt;server&gt;
    host 192.168.0.2
    port 24224
    standby  # 声明为备用
  &lt;/server&gt;

  # 所有的日志流都会存入磁盘，定期 flush 到 aggregators
  # 较长的 flush 可以减少 CPU
  &lt;buffer&gt;
    flush_interval 60s
  &lt;/buffer&gt;
&lt;/match&gt;

</code></pre>

<h3 id="3-数据丢失的场景">3、数据丢失的场景</h3>

<p>Forwarder 会把所有数据存放在 buffer 中，假如你在 match 中配置了 <code>buffer_type file</code>，则会将数据都存放在磁盘中，然后按照 <code>flush_interval</code> 定期将数据发送到 aggregator。</p>

<p>但是，如果 forwarder 进程在将数据写入 buffer 前死掉了，或者存放 buffer 的磁盘坏掉了，就会导致数据丢失。</p>

<h3 id="4-监控">4、监控</h3>

<h4 id="插件监控">插件监控</h4>

<p>fluentd 内置了一个 HTTP 接口，可以用来获取插件信息，只需要在配置文件里加上：</p>

<pre><code>&lt;source&gt;
  @type monitor_agent
  bind 0.0.0.0
  port 24220
&lt;/source&gt;

</code></pre>

<p>然后访问：<code>http://localhost:24220/api/plugins.json</code> 就可以拿到插件的信息。</p>

<hr />

<h2 id="八-性能调优">八、性能调优</h2>

<p>一般来说，fluentd 单节点的吞吐量大概是 10w/sec 左右。</p>

<p>要想提高性能的话，可以在输出端（match）指定 <code>num_threads</code> 来提高并发，在输入端安装 <code>fluent-plugin-multiprocess</code> 插件来提高 CPU 的利用率（Ruby 也有 GIL 问题）。</p>

<h3 id="1-负载均衡">1、负载均衡</h3>

<blockquote>
<ul>
<li><a href="https://www.fluentd.org/blog/fluentd-v0.14.12-has-been-released">Fluentd v0.14.12 has been released</a></li>
<li><a href="https://docs.fluentd.org/v0.12/articles/in_multiprocess">Multiprocess Input Plugin</a></li>
</ul>
</blockquote>

<p>fluentd 的 multiprocess 插件非常的鸡肋，只是帮你多启动几个 fluentd 进程，然后每个进程执行自己的配置文件。这个你使用进程管理器（如 supervisor 或 systemd）都能做到。</p>

<p>后来又引入了 multi worker 的参数，但是简单看了下后发现需要插件做适配，而我并没有精力去一个个的排查插件的兼容性，所以也就不考虑了。</p>

<p>为了提高 fluentd 的吞吐量，你有几个办法：</p>

<ul>
<li>拆分 fluentd 的配置文件，然后各自启动新的进程，缺点是各自监听不同的端口；</li>
<li>启动 multi worker，利用多核提高性能；</li>
<li>增加一个负载均衡，将流量分配到后端不同的 fluentd 进程上。</li>
</ul>

<p>我采用了最后一种方法，使用 haproxy 分发 tcp 到后端的 fluentd，写了一个 docker-compose 文件，开箱即用：</p>

<p><a href="https://github.com/Laisky/HelloWorld/tree/master/docker/docker_log/multi-process">https://github.com/Laisky/HelloWorld/tree/master/docker/docker_log/multi-process</a></p>

<p>不过在做拆分的时候，要考虑到当前的处理流程是否是无状态的，比如两个典型的场景：</p>

<ul>
<li>日志多行合并；</li>
<li>日志解析；</li>
</ul>

<p>其中多行合并就是有状态的，不能很好的进行并行。而日志解析是无状态的，可以根据需求开任意多的进程来处理。为了分担压力，建议将 fluentd 的处理拆为几个不同的步骤，其中第一个步骤仅进行多行合并等有状态的请求，然后第二层再并行的进行较重的解析等操作，最大程度的提高 fluentd 集群的吞吐量。</p>

<p>比如我当前生产环节的 fluentd 集群已经被玩成了这样：</p>

<p><img src="https://s3.laisky.com/uploads/2018/04/fluentd-cluster.png" alt="fluentd-cluster" /></p>

<hr />

<h2 id="九-demo">九、Demo</h2>

<h3 id="1-nginx-log">1、Nginx Log</h3>

<p>一个监听 Nginx 日志的例子：</p>

<pre><code>&lt;source&gt;
  @type tail
  @id nginx-access
  @label @nginx
  path /var/log/nginx/access.log
  pos_file /var/lib/fluentd/nginx-access.log.posg
  tag nginx.access
  format /^(?&lt;remote&gt;[^ ]*) (?&lt;host&gt;[^ ]*) \[(?&lt;time&gt;[^\]]*)\] (?&lt;code&gt;[^ ]*) &quot;(?&lt;method&gt;\S+)(?: +(?&lt;path&gt;[^\&quot;]*) +\S*)?&quot; (?&lt;size&gt;[^ ]*)(?: &quot;(?&lt;referer&gt;[^\&quot;]*)&quot; &quot;(?&lt;agent&gt;[^\&quot;]*)&quot;)?$/
  time_format %d/%b/%Y:%H:%M:%S %z
&lt;/source&gt;

&lt;source&gt;
  @type tail
  @id nginx-error
  @label @nginx
  path /var/log/nginx/error.log
  pos_file /var/lib/fluentd/nginx-error.log.posg
  tag nginx.error

  format /^(?&lt;time&gt;\d{4}/\d{2}/\d{2} \d{2}:\d{2}:\d{2}) \[(?&lt;log_level&gt;\w+)\] (?&lt;pid&gt;\d+).(?&lt;tid&gt;\d+): (?&lt;message&gt;.*)$/
&lt;/source&gt;

&lt;label @nginx&gt;
  &lt;match nginx.access&gt;
    @type mongo
    database nginx
    collection access
    host 10.47.12.119
    port 27016

    time_key time
    flush_interval 10s
  &lt;/match&gt;
  &lt;match nginx.error&gt;
    @type mongo
    database nginx
    collection error
    host 10.47.12.119
    port 27016

    time_key time
    flush_interval 10s
  &lt;/match&gt;
&lt;/label&gt;

</code></pre>

<p>为了匹配，你也需要修改 Nginx 的 <code>log_format</code> 为：</p>

<pre><code>log_format main '$remote_addr $host [$time_local] $status &quot;$request&quot; $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot;';

</code></pre>

<h3 id="2-docker-log">2、Docker Log</h3>

<p>如果你在启动 docker 时配置了 <code>--log_driver=fluentd</code> 的话，就可以用 fluentd 来接受 docker 的日志。</p>

<p>但是 docker 默认会按照换行符将日志拆成一条条的 json，所以你需要合并多行日志，并提取日志信息。 下面是一个例子，拆分成两层，先做合并，再做解析：</p>

<pre><code># 这一层只做合并，做完后就转发给下一层
&lt;filter geely.sit&gt;
  @type concat
  timeout_label @NORMAL  # concat 需要处理好 timeout flush，否则会丢数据
  flush_interval 5s
  key log
  stream_identity_key container_id
  multiline_start_regexp /^\d{4}-\d{2}-\d{2} +\d{2}:\d{2}:\d{2}.\d{3} +\|/
&lt;/filter&gt;

&lt;match **&gt;
  @type relabel
  @label @NORMAL
&lt;/match&gt;

&lt;label @NORMAL&gt;
  &lt;match **.sit&gt;
      @type copy
      &lt;store&gt;
          @type forward
          send_timeout 30s
          recover_wait 10s
          hard_timeout 30s
          &lt;server&gt;
              host lb
              port 24225
          &lt;/server&gt;
      &lt;/store&gt;
  &lt;/match&gt;
&lt;/label&gt;

</code></pre>

<p>第二层做解析，因为上一层拼合的日志包含 <code>\n</code>，所以要用 multiline 来做解析：</p>

<pre><code>&lt;filter geely.sit&gt;
  @type parser
  key_name log
  reserve_data true
  &lt;parse&gt;
    @type multiline
    format_firstline /^\d{4}-\d{2}-\d{2} +\d{2}:\d{2}:\d{2}.\d{3} +\|/
    format1 /^(?&lt;time&gt;.{23}) {0,}\| {0,}(?&lt;project&gt;[^ ]+) {0,}\| {0,}(?&lt;level&gt;[^ ]+) {0,}\| {0,}(?&lt;thread&gt;[^\|]+) {0,}\| {0,}(?&lt;class&gt;[^\:]+)\:(?&lt;line&gt;\d+) {0,}- {0,}(?&lt;message&gt;.+)/
    keep_time_key true
  &lt;/parse&gt;
&lt;/filter&gt;

</code></pre>

<h3 id="3-docker-化">3、Docker 化</h3>

<p>一个例子，执行的时候需要把 fluent.conf 挂载到 <code>/fluentd/etc/fluent.conf</code>，才能执行：</p>

<pre><code>FROM fluent/fluentd:v1.1.3

RUN apk add --update --virtual .build-deps \
    sudo build-base ruby-dev

RUN sudo gem install fluent-plugin-elasticsearch -v 2.8.6 \
    &amp;&amp; sudo gem install fluent-plugin-concat -v 2.1.0 \
    &amp;&amp; sudo gem install fluent-plugin-rewrite-tag-filter -v 2.0.2 \
    &amp;&amp; sudo gem install fluent-plugin-kafka -v 0.6.3 \
    &amp;&amp; sudo gem install fluent-plugin-cadvisor -v 0.3.1 \
    &amp;&amp; sudo gem install fluent-plugin-flowcounter -v 1.3 \
    &amp;&amp; sudo gem install fluent-plugin-ignore-filter -v 2.0.0 \
    &amp;&amp; sudo gem sources --clear-all \
    &amp;&amp; apk del .build-deps \
    &amp;&amp; rm -rf /var/cache/apk/* \
        /home/fluent/.gem/ruby/2.3.0/cache/*.gem

RUN mkdir -p /data/log/td-agent/buffer/

ENV FLUENTD_CONF=&quot;fluent.conf&quot;

ENTRYPOINT exec fluentd -c /fluentd/etc/${FLUENTD_CONF} -p /fluentd/plugins $FLUENTD_OPT

</code></pre>

<hr />

<h2 id="一〇-references">一〇、References</h2>

<hr />

<ol>
<li><p><a href="https://github.com/fluent/fluentd/blob/master/example/v1_literal_example.conf">fluentd: 字符串格式</a> <a href="#fnref-literal" title="Jump back to footnote 1 in the text.">↩</a></p></li>

<li><p><a href="https://www.fluentd.org/">fluentd 官网</a> <a href="#fnref-home" title="Jump back to footnote 2 in the text.">↩</a></p></li>

<li><p><a href="http://mayiwei.com/2014/03/03/fluentd-setup/">fluentd安装配置简介</a> <a href="#fnref-refer" title="Jump back to footnote 3 in the text.">↩</a></p></li>

<li><p><a href="http://docs.fluentd.org/articles/input-plugin-overview">fluentd: Input Plugin Overview</a> <a href="#fnref-input-plugin" title="Jump back to footnote 4 in the text.">↩</a></p></li>

<li><p><a href="http://docs.fluentd.org/articles/output-plugin-overview">fluentd: Output Plugin Overview</a> <a href="#fnref-output-plugin" title="Jump back to footnote 5 in the text.">↩</a></p></li>

<li><p><a href="http://docs.fluentd.org/articles/filter-plugin-overview">fluentd: Filter Plugin Overview</a> <a href="#fnref-filter-plugin" title="Jump back to footnote 6 in the text.">↩</a></p></li>
</ol>

              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">TAGGED IN</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://tangxusc.github.io/blog/tags/efk/">efk</a>

  <a class="tag tag--primary tag--small" href="https://tangxusc.github.io/blog/tags/fluentd/">fluentd</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://tangxusc.github.io/blog/2019/03/drone-ci%E7%9A%84%E5%AE%89%E8%A3%85docker%E7%89%88%E6%9C%AC/" data-tooltip="drone CI的安装(docker版本)">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://tangxusc.github.io/blog/2019/03/grpc-interceptor/" data-tooltip="gRPC-interceptor">
              
                  <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

            
              
                <div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2019 苏连云. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://tangxusc.github.io/blog/2019/03/drone-ci%E7%9A%84%E5%AE%89%E8%A3%85docker%E7%89%88%E6%9C%AC/" data-tooltip="drone CI的安装(docker版本)">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://tangxusc.github.io/blog/2019/03/grpc-interceptor/" data-tooltip="gRPC-interceptor">
              
                  <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="4">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://www.gravatar.com/avatar/a3d740bc2618da5f5a9de4fe94c05429?s=110" alt="Author&#39;s picture" />
    
    <h4 id="about-card-name">苏连云</h4>
    
      <div id="about-card-bio">酒剑仙,醉仙酒</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        小农民
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        chengdu
      </div>
    
  </div>
</div>

    <div id="algolia-search-modal" class="modal-container">
  <div class="modal">
    <div class="modal-header">
      <span class="close-button"><i class="fa fa-close"></i></span>
      <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
        <span class="searchby-algolia-text text-color-light text-small">by</span>
        <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
      </a>
      <i class="search-icon fa fa-search"></i>
      <form id="algolia-search-form">
        <input type="text" id="algolia-search-input" name="search"
          class="form-control input--large search-input" placeholder="Search" />
      </form>
    </div>
    <div class="modal-body">
      <div class="no-result text-color-light text-center">no post found</div>
      <div class="results">
        
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tangxusc.github.io/blog/2019/04/%E8%BF%88%E5%90%91istio-11-%E5%8D%87%E7%BA%A7%E5%88%B01.1.2/">
                <h3 class="media-heading">迈向istio-11 升级到1.1.2</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Apr 4, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">废话 istio经过8个月的发展和社区中的各位大佬的孜孜不倦的贡献,终于发布了1.1版本,新版本的口号叫企业级就绪(以后会不会出云供应商就绪?),这8个月中可以看到istio还是发生了很大的变化的,纵观历史,istio进行了三次腾飞:
 0.8 不在是模型了 1.0 生产就绪了(其实没有),抛弃了ingress,模型改动比较大 1.1 企业就绪了,理清楚了流量管理的模型啊啊啊啊,sidecar不再操碎了心,pilot解放了,mixer adapter又被默认的关了,ServiceEntry存在感突然就没啦.  废话太多了,接下来我们进入正题,去看看istio1.1到底更新了那些东西
 注意,不会全部的解析,只捡我认为重要的说.
 升级内容 安装 1.安装模式变化 现在提供了两个helm chart来安装,分别为istio-init和istio 这两个职责如下:
istio-init: 负责通过job.batch/istio-init-crd-10,job.batch/istio-init-crd-11 这两个job来安装istio的crd资源(一共53个,如果启用cert-manager则为58个),可通过命令查看:
$ kubectl get crds | grep 'istio.io\|certmanager.k8s.io' | wc -l 53  istio: 现在istio安装的时候是没有启用grafana,kiali的,并且已经说明使用kiali替换servicegraph,所以在安装时,需要手动开启:
# # addon grafana configuration # grafana: enabled: true # # addon kiali tracing configuration # kiali: enabled: true createDemoSecret: true  并且现在支持自定义kiali的用户名密码了,如果还是使用admin/admin 那么就需要createDemoSecret: true
istio现在提供了一个cni组件来避免init-container的privilege问题,不过这个cni需要kubelet的cni支持,kubelet的网络就两种kubenet和cni,也就是说 /etc/systemd/system/kubelet.service.d/10-kubeadm.conf文件中的
Environment=&quot;KUBELET_NETWORK_ARGS=--network-plugin=cni --cni-conf-dir=/etc/cni/net.d --cni-bin-dir=/opt/cni/bin&quot;  这里的--network-plugin=cni 值只能是 cni了</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tangxusc.github.io/blog/2019/03/controller-manager%E9%AB%98%E5%8F%AF%E7%94%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/">
                <h3 class="media-heading">Controller manager高可用实现方式</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Mar 3, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">本文由 简悦 SimpRead 转码， 原文地址 https://www.colabug.com/2801661.html
 这不是一系列入门级别的文章，也不是按部就班而来的，而是我看到哪里，发现有些代码写的精妙的地方，都值得我们学习下，顺手记录下来，一方面是让自己将来可以有迹可循，另外对大家应该也会有所帮助。而且记录本身成本并不是很高。
高可用部署情况下，需要部署多个 controller manager （以下简称 cm ），每个 cm 需要 --leader-elect=true 启动参数，即告知 cm 以高可用方式启动，谁要想进行真正的工作，必须先抢到锁，被选举为 leader 才行，而抢不到所得只能待机，在 leader 因为异常终止的时候，由剩余的其余节点再次获得锁。
关于分布式锁的实现很多，可以自己从零开始制造。当然更简单的是基于现有中间件，比如有基于 Redis 或数据库的实现方式，最近 Zookeeper/ETCD 也提供了相关功能。但 K8s 的实现并没有使用这些方式，而是另辟蹊径使用了资源锁的概念，简单来说就是通过创建 K8s 的资源（当前的实现中实现了 ConfigMap 和 Endpoint 两种类型的资源）来维护锁的状态。
分布式锁一般实现原理就是大家先去抢锁，抢到的人成为 leader ，然后 leader 会定期更新锁的状态，声明自己的活动状态，不让其他人把锁抢走。K8s 的资源锁也类似，抢到锁的节点会将自己的标记（目前是 hostname）设为锁的持有者，其他人则需要通过对比锁的更新时间和持有者来判断自己是否能成为新的 leader ，而 leader 则可以通过更新 RenewTime 来确保持续保有该锁。
大概看了下 K8s 的实现，老实说其实现方式并不算高雅，但是却给我们开拓了一种思路：K8s 里的 resource 是万能的，不要以为 Endpoint 只是 Endpoint 。不过反过来有时候也挺让人费解的，刚了解的时候容易摸不着头脑，也不是好事。而且 scheduler 和 cm 都采用了资源锁，但是实现起来却不尽相同，也值得吐槽下。不管怎么说，这个实现算是挺有意思的实现，值得我们深入了解下。
我们首先来看一下 cm 启动的时候，是如何去 初始化 抢锁的。启动的时候，如果指定了 --leader-elect=true 参数的话，则会进入下面的代码，首先获取自己的资源标志（这里是 hostname 加一串随机数字）。</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tangxusc.github.io/blog/2019/03/gitflow-%E5%B7%A5%E4%BD%9C%E6%B5%81/">
                <h3 class="media-heading">Gitflow 工作流</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Mar 3, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">本文由 简悦 SimpRead 转码， 原文地址 http://blog.jobbole.com/76867/
 这节介绍的 Gitflow工作流借鉴自在 nvie 的 _Vincent Driessen_。
Gitflow工作流定义了一个围绕项目发布的严格分支模型。虽然比功能分支工作流复杂几分，但提供了用于一个健壮的用于管理大型项目的框架。
Gitflow工作流没有用超出功能分支工作流的概念和命令，而是为不同的分支分配一个很明确的角色，并定义分支之间如何和什么时候进行交互。除了使用功能分支，在做准备、维护和记录发布也使用各自的分支。当然你可以用上功能分支工作流所有的好处：Pull Requests、隔离实验性开发和更高效的协作。
工作方式 Gitflow工作流仍然用中央仓库作为所有开发者的交互中心。和其它的工作流一样，开发者在本地工作并push分支到要中央仓库中。
历史分支 相对使用仅有的一个master分支，Gitflow工作流使用 2 个分支来记录项目的历史。master分支存储了正式发布的历史，而develop分支作为功能的集成分支。这样也方便master分支上的所有提交分配一个版本号。
剩下要说明的问题围绕着这 2 个分支的区别展开。
功能分支 每个新功能位于一个自己的分支，这样可以 push到中央仓库以备份和协作。但功能分支不是从master分支上拉出新分支，而是使用develop分支作为父分支。当新功能完成时，合并回develop分支。新功能提交应该从不直接与master分支交互。
注意，从各种含义和目的上来看，功能分支加上develop分支就是功能分支工作流的用法。但Gitflow工作流没有在这里止步。
发布分支 一旦develop分支上有了做一次发布（或者说快到了既定的发布日）的足够功能，就从develop分支上fork一个发布分支。新建的分支用于开始发布循环，所以从这个时间点开始之后新的功能不能再加到这个分支上 —— 这个分支只应该做Bug修复、文档生成和其它面向发布任务。一旦对外发布的工作都完成了，发布分支合并到master分支并分配一个版本号打好Tag。另外，这些从新建发布分支以来的做的修改要合并回develop分支。
使用一个用于发布准备的专门分支，使得一个团队可以在完善当前的发布版本的同时，另一个团队可以继续开发下个版本的功能。 这也打造定义良好的开发阶段（比如，可以很轻松地说，『这周我们要做准备发布版本 4.0』，并且在仓库的目录结构中可以实际看到）。
常用的分支约定：
用于新建发布分支的分支: develop 用于合并的分支: master 分支命名: release-* 或 release/*
维护分支 维护分支或说是热修复（hotfix）分支用于生成快速给产品发布版本（production releases）打补丁，这是唯一可以直接从master分支fork出来的分支。修复完成，修改应该马上合并回master分支和develop分支（当前的发布分支），master分支应该用新的版本号打好Tag。
为Bug修复使用专门分支，让团队可以处理掉问题而不用打断其它工作或是等待下一个发布循环。你可以把维护分支想成是一个直接在master分支上处理的临时发布。
示例 下面的示例演示本工作流如何用于管理单个发布循环。假设你已经创建了一个中央仓库。
创建开发分支 第一步为master分支配套一个develop分支。简单来做可以本地创建一个空的develop分支，push到服务器上：
git branch develop git push -u origin develop
以后这个分支将会包含了项目的全部历史，而master分支将只包含了部分历史。其它开发者这时应该克隆中央仓库，建好develop分支的跟踪分支：
git clone ssh://user@host/path/to/repo.git git checkout -b develop origin/develop</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tangxusc.github.io/blog/2019/03/go-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%8F%8A-pprof-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/">
                <h3 class="media-heading">Go 程序性能优化及 pprof 使用方法详解</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Mar 3, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">本文由 简悦 SimpRead 转码， 原文地址 https://www.jb51.net/article/127551.htm
 Go 程序性能优化及 pprof 使用方法详解  更新时间：2017 年 11 月 05 日 10:50:22 作者：snowInPluto
这篇文章主要为大家详细介绍了 Go 程序性能优化及 pprof 的使用方法，具有一定的参考价值，感兴趣的小伙伴们可以参考一下
Go 程序的性能优化及 pprof 的使用
程序的性能优化无非就是对程序占用资源的优化。对于服务器而言，最重要的两项资源莫过于 CPU 和内存。性能优化，就是在对于不影响程序数据处理能力的情况下，我们通常要求程序的 CPU 的内存占用尽量低。反过来说，也就是当程序 CPU 和内存占用不变的情况下，尽量地提高程序的数据处理能力或者说是吞吐量。
Go 的原生工具链中提供了非常多丰富的工具供开发者使用，其中包括 pprof。
对于 pprof 的使用要分成下面两部分来说。
Web 程序使用 pprof
先写一个简单的 Web 服务程序。程序在 9876 端口上接收请求。
package main import ( &quot;bytes&quot; &quot;io/ioutil&quot; &quot;log&quot; &quot;math/rand&quot; &quot;net/http&quot; _ &quot;net/http/pprof&quot; ) func main() { http.HandleFunc(&quot;/test&quot;, handler) log.Fatal(http.ListenAndServe(&quot;:9876&quot;, nil)) } func handler(w http.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tangxusc.github.io/blog/2019/03/golang%E5%A4%A7%E6%9D%80%E5%99%A8%E4%B9%8B%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90pprof/">
                <h3 class="media-heading">Golang大杀器之性能剖析PProf</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Mar 3, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">本文由 简悦 SimpRead 转码， 原文地址 https://github.com/EDDYCJY/blog/blob/master/golang/2018-09-15-Golang%20%E5%A4%A7%E6%9D%80%E5%99%A8%E4%B9%8B%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90%20PProf.md
 Golang 大杀器之性能剖析 PProf 前言 写了几吨代码，实现了几百个接口。功能测试也通过了，终于成功的部署上线了
结果，性能不佳，什么鬼？
想做性能分析 PProf 想要进行性能优化，首先瞩目在 Go 自身提供的工具链来作为分析依据，本文将带你学习、使用 Go 后花园，涉及如下：
 runtime/pprof：采集程序（非 Server）的运行数据进行分析 net/http/pprof：采集 HTTP Server 的运行时数据进行分析  是什么 pprof 是用于可视化和分析性能分析数据的工具
pprof 以 profile.proto 读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告）
profile.proto 是一个 Protocol Buffer v3 的描述文件，它描述了一组 callstack 和 symbolization 信息， 作用是表示统计分析的一组采样的调用栈，是很常见的 stacktrace 配置文件格式
支持什么使用模式  Report generation：报告生成 Interactive terminal use：交互式终端使用 Web interface：Web 界面  可以做什么  CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置 Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏 Block Profiling：阻塞分析，记录 goroutine 阻塞等待同步（包括定时器通道）的位置 Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况  一个简单的例子 我们将编写一个简单且有点问题的例子，用于基本的程序初步分析</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tangxusc.github.io/blog/2019/03/go%E6%A8%A1%E5%9D%97%E7%AE%80%E4%BB%8B/">
                <h3 class="media-heading">Go模块简介</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Mar 3, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">本文由 简悦 SimpRead 转码， 原文地址 https://roberto.selbach.ca/intro-to-go-modules/
 Go模块简介 发表于 2018年8月18日(https://roberto.selbach.ca/intro-to-go-modules/) 作者：Roberto Selbach
即将发布的Go编程语言版本1.11将为_模块_带来实验性支持 ，几天前Go.A的新依赖管理系统，我写了一篇关于它的快速帖子。自那篇文章上线以来，事情发生了一些变化，因为我们现在非常接近新版本，我认为现在是另一篇文章更适合实践的好时机。所以这就是我们要做的：我们将创建一个新的包，然后我们将发布一些版本，看看它是如何工作的。
创建模块 首先要做的事情。让我们创建我们的包。我们称之为“testmod”。这里有一个重要的细节：这个目录应该 在你的外面，因为默认情况下，模块支持在其中被禁用。Go模块是可能在某些时候完全消除的第一步。$GOPATH$GOPATH
$ mkdir testmod $ cd testmod  我们的包很简单：
package testmod import &quot;fmt&quot; // Hi returns a friendly greeting func Hi(name string) string { return fmt.Sprintf(&quot;Hi, %s&quot;, name) }  包完成但它仍然不是_模块_。让我们改变这一点。
$ go mod init github.com/robteix/testmod go: creating new go.mod: module github.com/robteix/testmod  这将go.mod在包目录中创建一个新文件，其中包含以下内容：
module github.com/robteix/testmod  这里不是很多，但这有效地将我们的包变成了一个 _模块_。我们现在可以将这个代码推送到一个存储库：
$ git init $ git add * $ git commit -am &quot;First commit&quot; $ git push -u origin master  到目前为止，任何愿意使用此软件包的人都会go get ：</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tangxusc.github.io/blog/2019/03/intellij-idea-%E5%9F%BA%E4%BA%8E%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84-rest-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%8B%E7%BB%8D/">
                <h3 class="media-heading">Intellij IDEA 基于编辑器的 REST 客户端介绍</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Mar 3, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">本文由 简悦 SimpRead 转码， 原文地址 https://blog.csdn.net/u011054333/article/details/78705256
 最近 Intellij IDEA 更新到了 2017.3 这一版本，这个版本又增加了很多新功能。我觉得其中这个基于编辑器的 REST 客户端这个功能很不错，可以为我们带来很多方便。这个功能并不仅仅在 Intellij IDEA 才有，最近更新的所有 Jetbrains 系 IIDE 都有这个功能。
以往我们开发和调试网络程序，用到的无非是这几种办法：浏览器 F12 工具、Fiddler、Wireshark、curl 等命令行工具、手动使用 HTTP 客户端类库编程。不过这些方法总是有些不好用。Jetbrains 这个基于编辑器的 REST 客户端用起来倒是让我眼前一亮。
使用方法 要使用这个功能很简单，在 IDE 中新建一个后缀名为.http的文件，然后就可以使用这个功能了。截图如下。
这个功能使用起来非常简单，使用大写的 HTTP 动词（GET、POST、DELETE、PUT 等等）后面加上要访问的网址即可，如果端口号不是 80 或者 443，可以使用冒号 + 端口号的形式写在网址后面。如果需要修改 Cookie、ContentType、UA 等设置，直接写在后面几行即可，Jetbrains 提供了非常完善的补全支持，我们只要敲第一个大写字母即可获得相应的代码提示。想要发起一个请求的时候，直接点击前面的绿色运行按钮即可。一个文件中可以保存多个请求，如果以后还想再次运行只要打开这个文件即可。
配置环境变量 Jetbrains 还提供了一个环境变量的功能，让我们使用这个编辑器 REST 客户端更加简单。只要在项目中添加一个名为rest-client.env.json的文件，然后配置不同环境下要使用的环境变量。然后就能在 REST 客户端中使用了。例如配置文件是这样的。
{ &quot;dev&quot;: { &quot;host&quot;: &quot;http://httpbin.org&quot; }, &quot;prod&quot;: { &quot;host&quot;: &quot;http://httpbin.org&quot; } }  那么在点击运行按钮的时候就会弹出选择要使用哪个环境变量。我们只要选择就可以针对不同环境使用不同配置了。在代码中只要使用双括号引用环境变量即可。</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tangxusc.github.io/blog/2019/03/java-%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-%E6%8F%92%E4%BB%B6%E5%8C%96%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86-apipluggable-annotation-processing-api/">
                <h3 class="media-heading">Java 奇技淫巧 - 插件化注解处理 API(Pluggable Annotation Processing API)</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Mar 3, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">本文由 简悦 SimpRead 转码， 原文地址 https://www.cnblogs.com/throwable/p/9139908.html
 插件化注解处理 API(Pluggable Annotation Processing API) Java 奇技淫巧 - 插件化注解处理 API(Pluggable Annotation Processing API) 参考资料  JDK6 的新特性之六: 插入式注解处理 API(Pluggable Annotation Processing API) Java Annotation Processing and Creating a Builder  简介 插件化注解处理 (Pluggable Annotation Processing)APIJSR 269 提供一套标准 API 来处理 AnnotationsJSR 175, 实际上 JSR 269 不仅仅用来处理 Annotation，我觉得更强大的功能是它建立了 Java 语言本身的一个模型, 它把 method、package、constructor、type、variable、enum、annotation 等 Java 语言元素映射为 Types 和 Elements，从而将 Java 语言的语义映射成为对象，我们可以在 javax.lang.model 包下面可以看到这些类。所以我们可以利用 JSR 269 提供的 API 来构建一个功能丰富的元编程 (metaprogramming) 环境。JSR 269 用 Annotation Processor 在编译期间而不是运行期间处理 Annotation, Annotation Processor 相当于编译器的一个插件, 所以称为插入式注解处理.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tangxusc.github.io/blog/2019/03/java-%E8%AF%BB%E5%86%99%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">
                <h3 class="media-heading">Java 读写锁实现原理</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Mar 3, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">本文由 简悦 SimpRead 转码， 原文地址 https://my.oschina.net/editorial-story/blog/1928306
 最近做的一个小项目中有这样的需求：整个项目有一份*config.json*保存着项目的一些配置，是存储在本地文件的一个资源，并且应用中存在读写（读 &gt;&gt; 写）更新问题。既然读写并发操作，那么就涉及到操作互斥，这里自然想到了读写锁，本文对读写锁方面的知识做个梳理。
为什么需要读写锁？ 与传统锁不同的是读写锁的规则是可以共享读，但只能一个写，总结起来为：读读不互斥，读写互斥，写写互斥，而一般的独占锁是：读读互斥，读写互斥，写写互斥，而场景中往往读远远大于写，读写锁就是为了这种优化而创建出来的一种机制。
注意是读远远大于写，一般情况下独占锁的效率低来源于高并发下对临界区的激烈竞争导致线程上下文切换。因此当并发不是很高的情况下，读写锁由于需要额外维护读锁的状态，可能还不如独占锁的效率高。因此需要根据实际情况选择使用。
一个简单的读写锁实现 根据上面理论可以利用两个 int 变量来简单实现一个读写锁，实现虽然烂，但是原理都是差不多的，值得阅读下。
public class ReadWriteLock { /** * 读锁持有个数 */ private int readCount = 0; /** * 写锁持有个数 */ private int writeCount = 0; /** * 获取读锁,读锁在写锁不存在的时候才能获取 */ public synchronized void lockRead() throws InterruptedException { // 写锁存在,需要wait while (writeCount &gt; 0) { wait(); } readCount++; } /** * 释放读锁 */ public synchronized void unlockRead() { readCount--; notifyAll(); } /** * 获取写锁,当读锁存在时需要wait.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tangxusc.github.io/blog/2019/03/java8-%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/">
                <h3 class="media-heading">Java8 日期和时间</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Mar 3, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">本文由 简悦 SimpRead 转码， 原文地址 https://blog.csdn.net/a80596890555/article/details/58687444
 如何正确处理时间 现实生活的世界里，时间是不断向前的，如果向前追溯时间的起点，可能是宇宙出生时，又或是是宇宙出现之前， 但肯定是我们目前无法找到的，我们不知道现在距离时间原点的精确距离。所以我们要表示时间， 就需要人为定义一个原点。
原点被规定为，格林威治时间 (GMT)1970 年 1 月 1 日的午夜 为起点, 之于为啥是 GMT 时间，大概是因为本初子午线在那的原因吧。
java 中的时间 如果你跟你朋友说：“我们 1484301456 一起去吃饭，别迟到！”，而你朋友能马上理解你说的时间，表示时间就会很简单， 只需要一个 long 值来表示原点的偏移量，这是个绝对时间，在世界范围内都适用。但实际上我们不能马上理解这串数字， 而且我们需要不同的时间单位来表示时间的跨度，比如一个季度是 3 个月，一个月有 30 天等。 你可以跟朋友约好 “明天这个时候再见面”, 你朋友很容易理解明天的意思，但要是没有’天’这个单位， 他就需要在那串数字上加上 86400(一天是 86400 秒)。
Java 三次引入处理时间的 API，JDK1.0 中包含了一个Date类，但大多数方法在 java1.1 引入Calendear类之后被弃用了。 它的实例都是可变的，而且它的 API 很难使用，比如月份是从 0 开始这种反人类的设置。
java8 引入的java.time API 已经纠正了之前的问题。它已经完全实现了JSR310规范。
java8 时间 API 介绍及使用 在新的时间 API 中，Instant表示一个精确的时间点，Duration和Period表示两个时间点之间的时间量。 LocalDate表示日期，即 xx 年 xx 月 xx 日，即不包括时间也不带时区。LocalTime与LocalDate类似， 但只包含时间。LocalDateTime则包含日期和时间。ZoneDateTime表示一个带时区的时间。 DateTimeFormatter提供格式化和解析功能。下面详细的介绍使用方法。</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
      </div>
    </div>
    <div class="modal-footer">
      <p class="results-count text-medium"
         data-message-zero="no post found"
         data-message-one="1 post found"
         data-message-other="{n} posts found">
         77 posts found
      </p>
    </div>
  </div>
</div>
    
  
    
    <div id="cover" style="background-image:url('https://tangxusc.github.io/blog/images/cover.jpg');"></div>
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="https://tangxusc.github.io/blog/js/script-qi9wbxp2ya2j6p7wx1i6tgavftewndznf4v0hy2gvivk1rxgc3lm7njqb6bz.min.js"></script>


<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
      <script>
        var disqus_config = function () {
          this.page.url = 'https:\/\/tangxusc.github.io\/blog\/2019\/03\/fluentd-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D\/';
          
            this.page.identifier = '\/2019\/03\/fluentd-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D\/'
          
        };
        (function() {
          
          
          if (window.location.hostname == "localhost") {
            return;
          }
          var d = document, s = d.createElement('script');
          var disqus_shortname = 'hugo-tranquilpeak-theme';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    
  




    
  </body>
</html>

