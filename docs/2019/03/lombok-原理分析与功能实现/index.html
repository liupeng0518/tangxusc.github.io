<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.55.0-DEV with theme Tranquilpeak 0.4.3-SNAPSHOT">
<meta name="author" content="苏连云">
<meta name="keywords" content="java, Lombok">
<meta name="description" content="
本文由 简悦 SimpRead 转码， 原文地址 https://blog.mythsman.com/2017/12/19/1/


这两天没什么重要的事情做，但是想着还要春招总觉得得学点什么才行，正巧想起来前几次面试的时候面试官总喜欢问一些框架的底层实现，但是我学东西比较倾向于用到啥学啥，因此在这些方面吃了很大的亏。而且其实很多框架也多而杂，代码起来费劲，无非就是几套设计模式套一套，用到的东西其实也就那么些，感觉没啥新意。刚这两天读” 深入理解 JVM” 的时候突然想起来有个叫 Lombok 的东西以前一直不能理解他的实现原理，现在正好趁着闲暇的时间研究研究。">


<meta property="og:description" content="
本文由 简悦 SimpRead 转码， 原文地址 https://blog.mythsman.com/2017/12/19/1/


这两天没什么重要的事情做，但是想着还要春招总觉得得学点什么才行，正巧想起来前几次面试的时候面试官总喜欢问一些框架的底层实现，但是我学东西比较倾向于用到啥学啥，因此在这些方面吃了很大的亏。而且其实很多框架也多而杂，代码起来费劲，无非就是几套设计模式套一套，用到的东西其实也就那么些，感觉没啥新意。刚这两天读” 深入理解 JVM” 的时候突然想起来有个叫 Lombok 的东西以前一直不能理解他的实现原理，现在正好趁着闲暇的时间研究研究。">
<meta property="og:type" content="article">
<meta property="og:title" content="Lombok 原理分析与功能实现">
<meta name="twitter:title" content="Lombok 原理分析与功能实现">
<meta property="og:url" content="https://tangxusc.github.io/blog/2019/03/lombok-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/">
<meta property="twitter:url" content="https://tangxusc.github.io/blog/2019/03/lombok-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/">
<meta property="og:site_name" content="苏连云的博客">
<meta property="og:description" content="
本文由 简悦 SimpRead 转码， 原文地址 https://blog.mythsman.com/2017/12/19/1/


这两天没什么重要的事情做，但是想着还要春招总觉得得学点什么才行，正巧想起来前几次面试的时候面试官总喜欢问一些框架的底层实现，但是我学东西比较倾向于用到啥学啥，因此在这些方面吃了很大的亏。而且其实很多框架也多而杂，代码起来费劲，无非就是几套设计模式套一套，用到的东西其实也就那么些，感觉没啥新意。刚这两天读” 深入理解 JVM” 的时候突然想起来有个叫 Lombok 的东西以前一直不能理解他的实现原理，现在正好趁着闲暇的时间研究研究。">
<meta name="twitter:description" content="
本文由 简悦 SimpRead 转码， 原文地址 https://blog.mythsman.com/2017/12/19/1/


这两天没什么重要的事情做，但是想着还要春招总觉得得学点什么才行，正巧想起来前几次面试的时候面试官总喜欢问一些框架的底层实现，但是我学东西比较倾向于用到啥学啥，因此在这些方面吃了很大的亏。而且其实很多框架也多而杂，代码起来费劲，无非就是几套设计模式套一套，用到的东西其实也就那么些，感觉没啥新意。刚这两天读” 深入理解 JVM” 的时候突然想起来有个叫 Lombok 的东西以前一直不能理解他的实现原理，现在正好趁着闲暇的时间研究研究。">
<meta property="og:locale" content="en-us">

  
    <meta property="article:published_time" content="2019-03-20T14:15:59">
  
  
    <meta property="article:modified_time" content="2019-03-20T14:15:59">
  
  
  
    
      <meta property="article:section" content="java">
    
      <meta property="article:section" content="Lombok">
    
  
  
    
      <meta property="article:tag" content="java">
    
      <meta property="article:tag" content="Lombok">
    
  


<meta name="twitter:card" content="summary">











  <meta property="og:image" content="https://tangxusc.github.io/blog/photo.png">
  <meta property="twitter:image" content="https://tangxusc.github.io/blog/photo.png">


    <title>Lombok 原理分析与功能实现</title>

    <link rel="icon" href="https://tangxusc.github.io/blog/favicon.png">
    

    

    <link rel="canonical" href="https://tangxusc.github.io/blog/2019/03/lombok-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="https://tangxusc.github.io/blog/css/style-nnm2spxvve8onlujjlegkkytaehyadd4ksxc1hyzzq9a2wvtrgbljqyulomn.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="4">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://tangxusc.github.io/blog/">苏连云的博客</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://tangxusc.github.io/blog/#about">
    
    
    
      
        <img class="header-picture" src="https://tangxusc.github.io/blog/photo.png" alt="Author&#39;s picture" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="4">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://tangxusc.github.io/blog/#about">
          <img class="sidebar-profile-picture" src="https://tangxusc.github.io/blog/photo.png" alt="Author&#39;s picture" />
        </a>
        <h4 class="sidebar-profile-name">苏连云</h4>
        
          <h5 class="sidebar-profile-bio">酒剑仙,醉仙酒</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://tangxusc.github.io/blog/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">Home</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://tangxusc.github.io/blog/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">Categories</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://tangxusc.github.io/blog/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">Tags</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://tangxusc.github.io/blog/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">Archives</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://tangxusc.github.io/blog/#about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">About</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/tangxusc/blog" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://shang.qq.com/wpa/qunwpa?idkey=927a7bf9677916a933d37dd47c45793d995d9af556579ca633ce0a7af2084d41" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-qq"></i>
      
      <span class="sidebar-button-desc">QQG:59593364</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="4"
        class="
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      Lombok 原理分析与功能实现
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2019-03-20T14:15:59&#43;08:00">
        
  March 20, 2019

      </time>
    
    
  
  
    <span>in</span>
    
      <a class="category-link" href="https://tangxusc.github.io/blog/categories/java">java</a>, 
    
      <a class="category-link" href="https://tangxusc.github.io/blog/categories/lombok">Lombok</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://blog.mythsman.com/2017/12/19/1/">https://blog.mythsman.com/2017/12/19/1/</a></p>
</blockquote>

<p>这两天没什么重要的事情做，但是想着还要春招总觉得得学点什么才行，正巧想起来前几次面试的时候面试官总喜欢问一些框架的底层实现，但是我学东西比较倾向于用到啥学啥，因此在这些方面吃了很大的亏。而且其实很多框架也多而杂，代码起来费劲，无非就是几套设计模式套一套，用到的东西其实也就那么些，感觉没啥新意。刚这两天读” 深入理解 JVM” 的时候突然想起来有个叫 Lombok 的东西以前一直不能理解他的实现原理，现在正好趁着闲暇的时间研究研究。</p>

<h3 id="代码">代码</h3>

<p>Lombok 是一个开源项目，源代码托管在 <a href="https://github.com/rzwitserloot/lombok">GITHUB/rzwitserloot</a>，如果需要在 maven 里引用，只需要添加下依赖:</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;version&gt;1.16.8&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<h3 id="功能">功能</h3>

<p>那么 Lombok 是做什么的呢？其实很简单，一个最简单的例子就是它能够实现通过添加注解，能够自动生成一些方法。比如这样的类:</p>

<pre><code>@Getter
class Test{
    private String value;
}
</code></pre>

<p>我们用 Lombok 提供的 @Getter 来注解这个类，这个类在编译的时候就会变成:</p>

<pre><code>class Test{
    private String value;
    public String getValue(){
        return this.value;
    }
}
</code></pre>

<p>当然 Lombok 也提供了很多其他的注解，这只是其中一个最典型的例子。其他的用法网上的资料已经很多了，这里就不啰嗦。
看上去是很方便的一个功能，尤其是在很多项目里有很多 bean，每次都要手写或自动生成 setter getter 方法，搞得代码很长而且没有啥意义，因此这个对简化代码的强迫症们还是很有吸引力的。
但是，我们发现这个包跟一般的包有很大区别，绝大多数 java 包都工作在运行时，比如 spring 提供的那种注解，通过在运行时用反射来实现业务逻辑。Lombok 这个东西工作却在编译期，在运行时是无法通过反射获取到这个注解的。
而且由于他相当于是在编译期对代码进行了修改，因此从直观上看，源代码甚至是语法有问题的。
一个更直接的体现就是，普通的包在引用之后一般的 IDE 都能够自动识别语法，但是 Lombok 的这些注解，一般的 IDE 都无法自动识别，比如我们上面的 Test 类，如果我们在其他地方这么调用了一下:</p>

<pre><code>Test test=new Test();
test.getValue();
</code></pre>

<p>IDE 的自动语法检查就会报错，说找不到这个 getValue 方法。因此如果要使用 Lombok 的话还需要配合安装相应的插件，防止 IDE 的自动检查报错。
因此，可以说这个东西的设计初衷比较美好，但是用起来比较麻烦，而且破坏了代码的完整性，很多项目组 (包括我自己) 都不高兴用。但是他的实现原理却还是比较好玩的，随便搜了搜发现网上最多也只提到了他修改了抽象语法树，虽说从感性上可以理解，但是还是想自己手敲一敲真正去实现一下。</p>

<h3 id="原理">原理</h3>

<p>翻了翻现有的资料，再加上自己的一些猜想，Lombok 的基本流程应该基本是这样：</p>

<ul>
<li>定义编译期的注解</li>
<li>利用 JSR269 api(Pluggable Annotation Processing API) 创建编译期的注解处理器</li>
<li>利用 tools.jar 的 javac api 处理 AST(抽象语法树)</li>
<li>将功能注册进 jar 包</li>
</ul>

<p>看起来还是比较简单的，但是不得不说坑也不少，搞了两天才把流程搞通。。。
下面就根据这个流程自己实现一个有类似功能的 Getter 类。</p>

<h2 id="手撸-getter">手撸 Getter</h2>

<p>实验的目的是自定义一个针对类的 Getter 注解，它能够读取该类的成员方法并自动生成 getter 方法。</p>

<h3 id="项目依赖">项目依赖</h3>

<p>由于比较习惯用 maven，我这里就用 maven 构建一下项目，修改下当前的 pom.xml 文件如下：</p>

<pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.mythsman.test&lt;/groupId&gt;
    &lt;artifactId&gt;getter&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;name&gt;test&lt;/name&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.sun&lt;/groupId&gt;
            &lt;artifactId&gt;tools&lt;/artifactId&gt;
            &lt;version&gt;1.8&lt;/version&gt;
            &lt;scope&gt;system&lt;/scope&gt;
            &lt;systemPath&gt;${java.home}/../lib/tools.jar&lt;/systemPath&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.1&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>

<p>主要定义了下项目名，除了默认依赖的 junit 之外 (其实并没有用)，这里添加了 tools.jar 包。这个包实在 jdk 的 lib 下面，因此 scope 是 system，由于 ${java.home} 变量表示的是 jre 的位置，因此还要根据这个位置找到实际的 tools.jar 的路径并写在 systemPath 里。
由于防止在写代码的时候用到 java8 的一些语法，这里配置了下编译插件使其支持 java8。</p>

<h3 id="创建-getter-注解">创建 Getter 注解</h3>

<p>定义注解 Getter.java:</p>

<pre><code>package com.mythsman.test;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.SOURCE)
public @interface Getter {
}
</code></pre>

<p>这里的 Target 我选择了 ElementType.TYPE 表示是对类的注解，Retention 选择了 RententionPolicy.SOURCE，表示这个注解只在编译期起作用，在运行时将不存在。这个比较简单，稍微复杂点的是对这个注解的处理机制。像 spring 那种注解是通过反射来获得注解对应的元素并实现业务逻辑，但是我们显然不希望在使用 Lombok 这种功能的时候还要编写其他的调用代码，况且用反射也获取不到编译期才存在的注解。
幸运的是 Java 早已支持了 JSR269 的规范，允许在编译时指定一个 processor 类来对编译阶段的注解进行干预，下面就来解决下这个处理器。</p>

<h3 id="创建-getter-注解的处理器">创建 Getter 注解的处理器</h3>

<h4 id="基本框架">基本框架</h4>

<p>自定义的处理器需要继承 AbstractProcessor 这个类，基本的框架大体应当如下:</p>

<pre><code>package com.mythsman.test;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.TypeElement;
import java.util.Set;

@SupportedAnnotationTypes(&quot;com.mythsman.test.Getter&quot;)
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class GetterProcessor extends AbstractProcessor {

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
    }

    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
        return true;
    }
}
</code></pre>

<p>需要定义两个注解，一个表示该处理器需要处理的注解，另外一个表示该处理器支持的源码版本。然后需要着重实现两个方法，init 跟 process。init 的主要用途是通过 ProcessingEnvironment 来获取编译阶段的一些环境信息; process 主要是实现具体逻辑的地方，也就是对 AST 进行处理的地方。</p>

<p>具体怎么做呢？</p>

<h4 id="init-方法">init 方法</h4>

<p>首先我们要重写下 init 方法，从环境里提取一些关键的类:</p>

<pre><code>private Messager messager;
private JavacTrees trees;
private TreeMaker treeMaker;
private Names names;

@Override
public synchronized void init(ProcessingEnvironment processingEnv) {
    super.init(processingEnv);
    this.messager = processingEnv.getMessager();
    this.trees = JavacTrees.instance(processingEnv);
    Context context = ((JavacProcessingEnvironment) processingEnv).getContext();
    this.treeMaker = TreeMaker.instance(context);
    this.names = Names.instance(context);
}
</code></pre>

<p>我们提取了四个主要的类:</p>

<ul>
<li>Messager 主要是用来在编译期打 log 用的</li>
<li>JavacTrees 提供了待处理的抽象语法树</li>
<li>TreeMaker 封装了创建 AST 节点的一些方法</li>
<li>Names 提供了创建标识符的方法</li>
</ul>

<h4 id="process-方法">process 方法</h4>

<p>process 方法的逻辑比较简单，但是由于这里的 api 对于我们来说比较陌生，因此写起来还是费了不少劲的：</p>

<pre><code>@Override
public synchronized boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
    Set&lt;? extends Element&gt; set = roundEnv.getElementsAnnotatedWith(Getter.class);
    set.forEach(element -&gt; {
        JCTree jcTree = trees.getTree(element);
        jcTree.accept(new TreeTranslator() {
            @Override
            public void visitClassDef(JCTree.JCClassDecl jcClassDecl) {
                List&lt;JCTree.JCVariableDecl&gt; jcVariableDeclList = List.nil();

                for (JCTree tree : jcClassDecl.defs) {
                    if (tree.getKind().equals(Tree.Kind.VARIABLE)) {
                        JCTree.JCVariableDecl jcVariableDecl = (JCTree.JCVariableDecl) tree;
                        jcVariableDeclList = jcVariableDeclList.append(jcVariableDecl);
                    }
                }

                jcVariableDeclList.forEach(jcVariableDecl -&gt; {
                    messager.printMessage(Diagnostic.Kind.NOTE, jcVariableDecl.getName() + &quot; has been processed&quot;);
                    jcClassDecl.defs = jcClassDecl.defs.prepend(makeGetterMethodDecl(jcVariableDecl));
                });
                super.visitClassDef(jcClassDecl);
            }

        });
    });

    return true;
}
</code></pre>

<p>步骤大概是下面这样：</p>

<ol>
<li>利用 roundEnv 的 getElementsAnnotatedWith 方法过滤出被 Getter 这个注解标记的类，并存入 set</li>
<li>遍历这个 set 里的每一个元素，并生成 jCTree 这个语法树</li>
<li>创建一个 TreeTranslator，并重写其中的 visitClassDef 方法，这个方法处理遍历语法树得到的类定义部分 jcClassDecl

<ol>
<li>创建一个 jcVariableDeclList 保存类的成员变量</li>
<li>遍历 jcTree 的所有成员 (包括成员变量和成员函数和构造函数)，过滤出其中的成员变量，并添加进 jcVariableDeclList</li>
<li>将 jcVariableDeclList 的所有变量转换成需要添加的 getter 方法，并添加进 jcClassDecl 的成员中</li>
<li>调用默认的遍历方法遍历处理后的 jcClassDecl</li>
</ol></li>
<li>利用上面的 TreeTranslator 去处理 jcTree</li>
</ol>

<p>接下来再实现 makeGetterMethodDecl 方法:</p>

<pre><code>private JCTree.JCMethodDecl makeGetterMethodDecl(JCTree.JCVariableDecl jcVariableDecl) {

    ListBuffer&lt;JCTree.JCStatement&gt; statements = new ListBuffer&lt;&gt;();
    statements.append(treeMaker.Return(treeMaker.Select(treeMaker.Ident(names.fromString(&quot;this&quot;)), jcVariableDecl.getName())));
    JCTree.JCBlock body = treeMaker.Block(0, statements.toList());
    return treeMaker.MethodDef(treeMaker.Modifiers(Flags.PUBLIC), getNewMethodName(jcVariableDecl.getName()), jcVariableDecl.vartype, List.nil(), List.nil(), List.nil(), body, null);
}

private Name getNewMethodName(Name name) {
    String s = name.toString();
    return names.fromString(&quot;get&quot; + s.substring(0, 1).toUpperCase() + s.substring(1, name.length()));
}
</code></pre>

<p>逻辑就是读取变量的定义，并创建对应的 Getter 方法，并试图用驼峰命名法。</p>

<p>整体上难点还是集中在 api 的使用上，还有一些细微的注意点:
首先，messager 的 printMessage 方法在打印 log 的时候会自动过滤重复的 log 信息。
其次，这里的 list 并不是 java.util 里面的 list，而是一个自定义的 list，这个 list 的用法比较坑爹，他采用的是这样的方式:</p>

<pre><code>package com.sun.tools.javac.util;

public class List&lt;A&gt; extends AbstractCollection&lt;A&gt; implements java.util.List&lt;A&gt; {
    public A head;
    public List&lt;A&gt; tail;
    
    //...
    
    List(A var1, List&lt;A&gt; var2) {
        this.tail = var2;
        this.head = var1;
    }
    
    public List&lt;A&gt; prepend(A var1) {
        return new List(var1, this);
    }
    
    public static &lt;A&gt; List&lt;A&gt; of(A var0) {
        return new List(var0, nil());
    }
    
    public List&lt;A&gt; append(A var1) {
        return of(var1).prependList(this);
    }
    
    public static &lt;A&gt; List&lt;A&gt; nil() {
        return EMPTY_LIST;
    }
    //...
}
</code></pre>

<p>挺有趣的，用这种叫 cons 而不是 list 的数据结构，添加元素的时候就把自己赋给自己的 tail, 新来的元素放进 head。不过需要注意的是这个东西不支持链式调用，prepend 之后还要将新值赋给自己。
而且这里在创建 getter 方法的时候还要把参数写全写对了，尤其是添加 this 指针的这种用法。</p>

<h4 id="测试类">测试类</h4>

<p>上面基本就是所有功能代码了，接下来我们要写一个类来测试一下 (App.java)：</p>

<pre><code>package com.mythsman.test;

@Getter
public class App {
    private String value;

    private String value2;

    public App(String value) {
        this.value = value;
    }

    public static void main(String[] args) {
        App app = new App(&quot;it works&quot;);
        System.out.println(app.getValue());
    }
}
</code></pre>

<p>不过，先不要急着构建，构建了肯定会失败，因为这原则上应该是两个项目。Getter.java 是注解类没问题，但是 GetterProcessor.java 是处理器，App.java 需要在编译期调用这个处理器，因此这两个东西是不能一起编译的，正确的编译方法应该是类似下面这样，写成 compile.sh 脚本就是：</p>

<pre><code>#!/usr/bin/env bash

if [ -d classes ]; then
    rm -rf classes;
fi
mkdir classes

javac -cp $JAVA_HOME/lib/tools.jar com/mythsman/test/Getter* -d classes/

javac -cp classes -d classes -processor com.mythsman.test.GetterProcessor com/mythsman/test/App.java

javap -p classes com/mythsman/test/App.class

java -cp classes com.mythsman.test.App
</code></pre>

<p>其实是五个步骤:</p>

<ol>
<li>创建保存 class 文件的文件夹</li>
<li>导入 tools.jar，编译 processor 并输出</li>
<li>编译 App.java，并使用 javac 的 - processor 参数指定编译阶段的处理器 GetterProcessor</li>
<li>用 javap 显示编译后的 App.class 文件 (非必须，方便看结果)</li>
<li>执行测试类</li>
</ol>

<p>好了，进入项目的根目录，当前的目录结构应该是这样的:</p>

<pre><code>.
├── pom.xml
├── src
│   ├── main
│   │   ├── java
│   │   │   ├── com
│   │   │   │   └── mythsman
│   │   │   │       └── test
│   │   │   │           ├── App.java
│   │   │   │           ├── Getter.java
│   │   │   │           └── GetterProcessor.java
│   │   │   └── compile.sh
</code></pre>

<p>调用 compile.sh，输出如下:</p>

<pre><code>Note: value has been processed
Note: value2 has been processed
Compiled from &quot;App.java&quot;
public class com.mythsman.test.App {
  private java.lang.String value;
  private java.lang.String value2;
  public java.lang.String getValue2();
  public java.lang.String getValue();
  public com.mythsman.test.App(java.lang.String);
  public static void main(java.lang.String[]);
}
it works
</code></pre>

<p>Note 行就是在 GetterProcessor 类里通过 messager 打印的 log，中间的是 javap 反编译的结果，最后一行表示测试调用成功。</p>

<h4 id="maven-构建并打包">Maven 构建并打包</h4>

<p>上面的测试部分其实是为了测试而测试，其实这应当是两个项目，一个是 processor 项目，这个项目应当被打成一个 jar 包，供调用者使用；另一个项目是 app 项目，这个项目是专门使用 jar 包的，他并不希望添加任何额外编译参数，就跟 lombok 的用法一样。
简单来说，就是我们希望把 processor 打成一个包，并且在使用时不需要添加额外参数。
那么如何在调用的时候不用加参数呢，其实我们知道 java 在编译的时候会去资源文件夹下读一个 META-INF 文件夹，这个文件夹下面除了 MANIFEST.MF 文件之外，还可以添加一个 services 文件夹，我们可以在这个文件夹下创建一个文件，文件名是 javax.annotation.processing.Processor，文件内容是 com.mythsman.test.GetterProcessor。
我们知道 maven 在编译前会先拷贝资源文件夹，然后当他在编译时候发现了资源文件夹下的 META-INF/serivces 文件夹时，他就会读取里面的文件，并将文件名所代表的接口用文件内容表示的类来实现。这就相当于做了 - processor 参数该做的事了。
当然这个文件我们并不希望调用者去写，而是希望在 processor 项目里集成，调用的时候能直接继承 META-INF。</p>

<p>好了，我们先删除 App.java 和 compile.sh，添加下 META-INF 文件夹，当前目录结构应该是这样的：</p>

<pre><code>.
├── pom.xml
├── src
│   └── main
│       ├── java
│       │   └── com
│       │       └── mythsman
│       │           └── test
│       │               ├── Getter.java
│       │               └── GetterProcessor.java
│       └── resources
│           └── META-INF
│               └── services
│                   └── javax.annotation.processing.Processor

</code></pre>

<p>当然，我们还不能编译，因为 processor 项目并不需要把自己添加为 processor(况且自己还没编译呢怎么调用自己)。。。完了，好像死循环了，自己在编译的时候不能添加 services 文件夹，但是又需要打的包里有 services 文件夹，这该怎么搞呢？
其实很简单，配置一下 maven 的插件就行，打开 pom.xml, 在 project/build / 标签里添加下面的配置:</p>

<pre><code>&lt;build&gt;
   &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/resources&lt;/directory&gt;
            &lt;excludes&gt;
                &lt;exclude&gt;META-INF/**/*&lt;/exclude&gt;
            &lt;/excludes&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.6&lt;/version&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;id&gt;process-META&lt;/id&gt;
                    &lt;phase&gt;prepare-package&lt;/phase&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;copy-resources&lt;/goal&gt;
                    &lt;/goals&gt;
                    &lt;configuration&gt;
                        &lt;outputDirectory&gt;target/classes&lt;/outputDirectory&gt;
                        &lt;resources&gt;
                            &lt;resource&gt;
                                &lt;directory&gt;${basedir}/src/main/resources/&lt;/directory&gt;
                                &lt;includes&gt;
                                    &lt;include&gt;**/*&lt;/include&gt;
                                &lt;/includes&gt;
                            &lt;/resource&gt;
                        &lt;/resources&gt;
                    &lt;/configuration&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
        ...
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>

<p>我们知道 maven 构建的第一步就是调用 maven-resources-plugin 插件的 resources 命令，将 resources 文件夹复制到 target/classes 中，那么我们配置一下 resources 标签，过滤掉 META-INF 文件夹，这样在编译的时候就不会找到 services 的配置了。然后我们在打包前 (prepare-package 生命周期) 再利用 maven-resources-plugin 插件的 copy-resources 命令把 services 文件夹重新拷贝过来不就好了么。
这样配置好了，就可以直接执行<code>mvn clean install</code>打包提交到本地私服:</p>

<pre><code>myths@pc:~/Desktop/test$ mvn clean install
[INFO] Scanning for projects...
[INFO] 
[INFO] ------------------------------------------------------------------------
[INFO] Building test 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ getter ---
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ getter ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Copying 0 resource
[INFO] 
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ getter ---
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 2 source files to /home/myths/Desktop/test/target/classes
[INFO] 
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ getter ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory /home/myths/Desktop/test/src/test/resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ getter ---
[INFO] No sources to compile
[INFO] 
[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ getter ---
[INFO] No tests to run.
[INFO] 
[INFO] --- maven-resources-plugin:2.6:copy-resources (process-META) @ getter ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] Copying 1 resource
[INFO] 
[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ getter ---
[INFO] Building jar: /home/myths/Desktop/test/target/getter-1.0-SNAPSHOT.jar
[INFO] 
[INFO] --- maven-install-plugin:2.4:install (default-install) @ getter ---
[INFO] Installing /home/myths/Desktop/test/target/getter-1.0-SNAPSHOT.jar to /home/myths/.m2/repository/com/mythsman/test/getter/1.0-SNAPSHOT/getter-1.0-SNAPSHOT.jar
[INFO] Installing /home/myths/Desktop/test/pom.xml to /home/myths/.m2/repository/com/mythsman/test/getter/1.0-SNAPSHOT/getter-1.0-SNAPSHOT.pom
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 3.017 s
[INFO] Finished at: 2017-12-19T19:57:04+08:00
[INFO] Final Memory: 16M/201M
[INFO] ------------------------------------------------------------------------
</code></pre>

<p>可以看到这里的 process-META 作用生效。</p>

<h4 id="调用-jar-包测试">调用 jar 包测试</h4>

<p>重新创建一个测试项目 app：</p>

<pre><code>.
├── pom.xml
└── src
    └── main
        └── java
            └── com
                └── mythsman
                    └── test
                        └── App.java
</code></pre>

<p>pom.xml:</p>

<pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.mythsman.test&lt;/groupId&gt;
    &lt;artifactId&gt;app&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;name&gt;main&lt;/name&gt;
    &lt;url&gt;http://maven.apache.org&lt;/url&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.mythsman.test&lt;/groupId&gt;
            &lt;artifactId&gt;getter&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.1&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>

<p>App.java:</p>

<pre><code>package com.mythsman.test;

@Getter
public class App {
    private String value;

    private String value2;

    public App(String value) {
        this.value = value;
    }

    public static void main(String[] args) {
        App app = new App(&quot;it works&quot;);
        System.out.println(app.getValue());
    }
}
</code></pre>

<p>编译并执行:</p>

<pre><code>
mvn clean compile &amp;&amp; java -cp target/classes com.mythsman.test.App
</code></pre>

<p>最后就会在构建成功后打印”it works”。</p>

<h2 id="参考资料">参考资料</h2>

<p><a href="https://github.com/rzwitserloot/lombok">GITHUB/lombok</a></p>

<p><a href="https://segmentfault.com/a/1190000005133786">使用 lombok 简化 Java 代码</a></p>

<p><a href="https://blog.zenfery.cc/archives/78.html">Java 注解 (3)- 注解处理器</a></p>

<p><a href="https://stackoverflow.com/questions/6107197/how-does-lombok-work">stackoverflow/How does lombok work?</a></p>

<p><a href="https://my.oschina.net/superpdm/blog/129715">【翻译】Javac 骇客指南</a></p>

<p><a href="https://www.cnblogs.com/wade-luffy/p/6050331.html">Javac 早期 (编译期)</a></p>

<p><a href="http://xigua366.iteye.com/blog/2080668">利用 maven 中 resources 插件的 copy-resources 目标进行资源 copy 和过滤</a></p>
              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">TAGGED IN</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://tangxusc.github.io/blog/tags/java/">java</a>

  <a class="tag tag--primary tag--small" href="https://tangxusc.github.io/blog/tags/lombok/">Lombok</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://tangxusc.github.io/blog/2019/03/kubernetes-operator-sdk/" data-tooltip="Kubernetes Operator SDK">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://tangxusc.github.io/blog/2019/03/minikube-%E5%AE%89%E8%A3%85/" data-tooltip="Minikube 安装">
              
                  <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

            
              
                <div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2019 苏连云. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://tangxusc.github.io/blog/2019/03/kubernetes-operator-sdk/" data-tooltip="Kubernetes Operator SDK">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://tangxusc.github.io/blog/2019/03/minikube-%E5%AE%89%E8%A3%85/" data-tooltip="Minikube 安装">
              
                  <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="4">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://tangxusc.github.io/blog/photo.png" alt="Author&#39;s picture" />
    
    <h4 id="about-card-name">苏连云</h4>
    
      <div id="about-card-bio">酒剑仙,醉仙酒</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        小农民
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        chengdu
      </div>
    
  </div>
</div>

    <div id="algolia-search-modal" class="modal-container">
  <div class="modal">
    <div class="modal-header">
      <span class="close-button"><i class="fa fa-close"></i></span>
      <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
        <span class="searchby-algolia-text text-color-light text-small">by</span>
        <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
      </a>
      <i class="search-icon fa fa-search"></i>
      <form id="algolia-search-form">
        <input type="text" id="algolia-search-input" name="search"
          class="form-control input--large search-input" placeholder="Search" />
      </form>
    </div>
    <div class="modal-body">
      <div class="no-result text-color-light text-center">no post found</div>
      <div class="results">
        
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tangxusc.github.io/blog/2019/05/%E8%BF%88%E5%90%91istio-13-%E8%87%AA%E5%AE%9A%E4%B9%89adapter%E4%BF%AE%E6%94%B9%E8%AF%B7%E6%B1%82%E5%A4%B4/">
                <h3 class="media-heading">迈向istio-13 自定义adapter(修改请求头)</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  May 5, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>在istio中mixer组件负责策略控制和遥测收集数据,是高度模块化和可扩展的组件.</p>

<p>mixer处理不同基础设施后端的灵活性是通过适配器模型插件来实现的,每个插件都被成为<code>Adapter</code>,用户通过配置使用Adapter向mixer注册自身,并设置适配规则,绑定模板,mixer通过和每个插件进行grpc连接,对策略和遥测进行操作</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tangxusc.github.io/blog/2019/05/networkpolicy%E4%BB%8B%E7%BB%8D/">
                <h3 class="media-heading">NetworkPolicy介绍</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  May 5, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>在kubernetes中的所有的pod在默认情况下,网络都是互通的,pod接收来自任何来源的流量.</p>

<p>那么我们如何限制pod的网络通信,防止非法访问呢?</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tangxusc.github.io/blog/2019/05/%E4%BA%B2%E5%92%8C%E6%80%A7%E8%B0%83%E5%BA%A6/">
                <h3 class="media-heading">亲和性调度</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  May 5, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>在kubernetes中对pod的调度由调度控制器负责,在调度的时候有很大的随机性.</p>

<p>但是我们很多时候需要容器更多的分散在不同的node上,有一些情况又需要尽量集中在一起,减少网络开销</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tangxusc.github.io/blog/2019/05/local-persistent-volume-%E4%BB%8B%E7%BB%8D/">
                <h3 class="media-heading">Local Persistent Volume 介绍</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  May 5, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>在kubernetes中,存储一直是一个较为头疼的问题,在面对持久化存储,我们可以选择各种文件系统,但是对于那些临时存储的文件,我们则需要一种本地存储的能力,在kubernetes1.14中为我们提供了一种本地存储<code>localPV</code>,本文将围绕此展开.</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tangxusc.github.io/blog/2019/05/%E4%BB%8A%E6%97%A5%E5%BF%83%E6%83%85-%E4%B8%8A%E5%96%84%E8%8B%A5%E6%B0%B4/">
                <h3 class="media-heading">今日心情-上善若水</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  May 5, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>一天又一天,每一天都那么一样又不那么一样.</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tangxusc.github.io/blog/2019/05/code-generator%E4%BD%BF%E7%94%A8/">
                <h3 class="media-heading">code-generator使用</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  May 5, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>client-go为我们提供了kubernetes原生资源的informer和clientset等等的访问,那么自定义资源如何操作呢? 本文将为你介绍..</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tangxusc.github.io/blog/2019/05/%E7%90%86%E8%A7%A3kubernetes-tools/cache%E5%8C%85-7/">
                <h3 class="media-heading">理解kubernetes tools/cache包-7</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  May 5, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://blog.csdn.net/weixin_39961559/article/details/81948541">https://blog.csdn.net/weixin_39961559/article/details/81948541</a></p>
</blockquote>

<p>本系列深入介绍了informer的原理,这是本系列第七节,也是最后一节</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tangxusc.github.io/blog/2019/05/%E7%90%86%E8%A7%A3kubernetes-tools/cache%E5%8C%85-6/">
                <h3 class="media-heading">理解kubernetes tools/cache包-6</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  May 5, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://blog.csdn.net/weixin_39961559/article/details/81948239">https://blog.csdn.net/weixin_39961559/article/details/81948239</a></p>
</blockquote>

<p>本系列深入介绍了informer的原理,这是本系列第六节</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tangxusc.github.io/blog/2019/05/%E7%90%86%E8%A7%A3kubernetes-tools/cache%E5%8C%85-5/">
                <h3 class="media-heading">理解kubernetes tools/cache包-5</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  May 5, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://blog.csdn.net/weixin_39961559/article/details/81946899">https://blog.csdn.net/weixin_39961559/article/details/81946899</a></p>
</blockquote>

<p>本系列深入介绍了informer的原理,这是本系列第五节</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tangxusc.github.io/blog/2019/05/%E7%90%86%E8%A7%A3kubernetes-tools/cache%E5%8C%85-4/">
                <h3 class="media-heading">理解kubernetes tools/cache包-4</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  May 5, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://blog.csdn.net/weixin_39961559/article/details/81946398">https://blog.csdn.net/weixin_39961559/article/details/81946398</a></p>
</blockquote>

<p>本系列深入介绍了informer的原理,这是本系列第四节</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
      </div>
    </div>
    <div class="modal-footer">
      <p class="results-count text-medium"
         data-message-zero="no post found"
         data-message-one="1 post found"
         data-message-other="{n} posts found">
         94 posts found
      </p>
    </div>
  </div>
</div>
    
  
    
    <div id="cover" style="background-image:url('https://tangxusc.github.io/blog/images/cover.jpg');"></div>
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="https://tangxusc.github.io/blog/js/script-qi9wbxp2ya2j6p7wx1i6tgavftewndznf4v0hy2gvivk1rxgc3lm7njqb6bz.min.js"></script>


<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
      <script>
        var disqus_config = function () {
          this.page.url = 'https:\/\/tangxusc.github.io\/blog\/2019\/03\/lombok-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0\/';
          
            this.page.identifier = '\/2019\/03\/lombok-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0\/'
          
        };
        (function() {
          
          
          if (window.location.hostname == "localhost") {
            return;
          }
          var d = document, s = d.createElement('script');
          var disqus_shortname = 'tangxu-blog';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    
  




    
  </body>
</html>

