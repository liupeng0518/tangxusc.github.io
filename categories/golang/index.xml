<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on 苏连云的博客</title>
    <link>https://tangxusc.github.io/categories/golang/</link>
    <description>Recent content in Golang on 苏连云的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 15 Nov 2019 09:15:59 +0800</lastBuildDate>
    
	<atom:link href="https://tangxusc.github.io/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go Module如何发布v2及以上版本</title>
      <link>https://tangxusc.github.io/2019/11/go-module%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83v2%E5%8F%8A%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC/</link>
      <pubDate>Fri, 15 Nov 2019 09:15:59 +0800</pubDate>
      
      <guid>https://tangxusc.github.io/2019/11/go-module%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83v2%E5%8F%8A%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文由 &lt;a href=&#34;http://ksria.com/simpread/&#34;&gt;简悦 SimpRead&lt;/a&gt; 转码， 原文地址 &lt;a href=&#34;https://blog.cyeam.com/go/2019/03/12/go-version&#34;&gt;https://blog.cyeam.com/go/2019/03/12/go-version&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;用上 go mod 之后，依赖包都是通过版本打 tag 的形式确定版本号。比如 &lt;code&gt;github.com/mnhkahn/gogogo v1.0.9&lt;/code&gt;。每次都改动都是在累加低位的版本号，一直这么用也挺安逸的。突然有一天，我的一个底层包需要大改，导致和之前的版本彻底不兼容，这种情况下如何设置版本号，如何能让调用方成功接入？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>golang select-case实现机制</title>
      <link>https://tangxusc.github.io/2019/11/golang-select-case%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Fri, 15 Nov 2019 09:15:59 +0800</pubDate>
      
      <guid>https://tangxusc.github.io/2019/11/golang-select-case%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文由 &lt;a href=&#34;http://ksria.com/simpread/&#34;&gt;简悦 SimpRead&lt;/a&gt; 转码， 原文地址 &lt;a href=&#34;https://hitzhangjie.github.io/jekyll/update/2018/05/19/golang-select-case%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6.html&#34;&gt;https://hitzhangjie.github.io/jekyll/update/2018/05/19/golang-select-case%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在介绍 select-case 实现机制之前，最好先了解下 chan 操作规则，明白 goroutine 何时阻塞，又在什么时机被唤醒，这对后续理解 select-case 实现有帮助。所以接下来先介绍 chan 操作规则，然后再介绍 select-case 的实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用Go处理每分钟百万请求</title>
      <link>https://tangxusc.github.io/2019/11/%E4%BD%BF%E7%94%A8go%E5%A4%84%E7%90%86%E6%AF%8F%E5%88%86%E9%92%9F%E7%99%BE%E4%B8%87%E8%AF%B7%E6%B1%82/</link>
      <pubDate>Fri, 15 Nov 2019 09:15:59 +0800</pubDate>
      
      <guid>https://tangxusc.github.io/2019/11/%E4%BD%BF%E7%94%A8go%E5%A4%84%E7%90%86%E6%AF%8F%E5%88%86%E9%92%9F%E7%99%BE%E4%B8%87%E8%AF%B7%E6%B1%82/</guid>
      <description>&lt;p&gt;这篇文章在medium上很火，作者以实际案例来分析，讲得很好。&lt;/p&gt;

&lt;p&gt;我们经常听说使用Go的goroutine和channel很容易实现高并发，那是不是全部代码都放在goroutine中运行就可以实现高并发程序了呢？很显然并不是。&lt;/p&gt;

&lt;p&gt;这篇文章将教大家如何一步一步写出一个简单的， 高并发的Go程序。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>golang package和module解析</title>
      <link>https://tangxusc.github.io/2019/05/golang-package%E5%92%8Cmodule%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 15 May 2019 09:15:59 +0800</pubDate>
      
      <guid>https://tangxusc.github.io/2019/05/golang-package%E5%92%8Cmodule%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;p&gt;go语言中的package和module是我们经常会用到的功能,本文将详细的描述这两个功能的用法.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;本文基于golang 1.12.2和go module,之前老的gopath的使用方式不再推荐.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Go 程序性能优化及 pprof 使用方法详解</title>
      <link>https://tangxusc.github.io/2019/03/go-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%8F%8A-pprof-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Wed, 20 Mar 2019 14:15:59 +0800</pubDate>
      
      <guid>https://tangxusc.github.io/2019/03/go-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%8F%8A-pprof-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文由 &lt;a href=&#34;http://ksria.com/simpread/&#34;&gt;简悦 SimpRead&lt;/a&gt; 转码， 原文地址 &lt;a href=&#34;https://www.jb51.net/article/127551.htm&#34;&gt;https://www.jb51.net/article/127551.htm&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这篇文章主要为大家详细介绍了 Go 程序性能优化及 pprof 的使用方法，具有一定的参考价值，感兴趣的小伙伴们可以参考一下&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang大杀器之性能剖析PProf</title>
      <link>https://tangxusc.github.io/2019/03/golang%E5%A4%A7%E6%9D%80%E5%99%A8%E4%B9%8B%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90pprof/</link>
      <pubDate>Wed, 20 Mar 2019 14:15:59 +0800</pubDate>
      
      <guid>https://tangxusc.github.io/2019/03/golang%E5%A4%A7%E6%9D%80%E5%99%A8%E4%B9%8B%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90pprof/</guid>
      <description>&lt;p&gt;写了几吨代码，实现了几百个接口。功能测试也通过了，终于成功的部署上线了&lt;/p&gt;

&lt;p&gt;结果，性能不佳，什么鬼？&lt;/p&gt;

&lt;p&gt;本文教你使用 PProf来分析程序&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go模块简介</title>
      <link>https://tangxusc.github.io/2019/03/go%E6%A8%A1%E5%9D%97%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Wed, 20 Mar 2019 14:15:59 +0800</pubDate>
      
      <guid>https://tangxusc.github.io/2019/03/go%E6%A8%A1%E5%9D%97%E7%AE%80%E4%BB%8B/</guid>
      <description>&lt;p&gt;go module模块的简介和使用&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>gRPC-interceptor</title>
      <link>https://tangxusc.github.io/2019/03/grpc-interceptor/</link>
      <pubDate>Wed, 20 Mar 2019 14:15:59 +0800</pubDate>
      
      <guid>https://tangxusc.github.io/2019/03/grpc-interceptor/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本文由 &lt;a href=&#34;http://ksria.com/simpread/&#34;&gt;简悦 SimpRead&lt;/a&gt; 转码， 原文地址 &lt;a href=&#34;https://colobu.com/2017/04/17/dive-into-gRPC-interceptor/&#34;&gt;https://colobu.com/2017/04/17/dive-into-gRPC-interceptor/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;gRPC-Go 增加了拦截器 (interceptor) 的功能， 就像 Java Servlet 中的 filter 一样，可以对 RPC 的请求和响应进行拦截处理，而且既可以在客户端进行拦截，也可以对服务器端进行拦截。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>golang日志库</title>
      <link>https://tangxusc.github.io/2019/03/golang%E6%97%A5%E5%BF%97%E5%BA%93/</link>
      <pubDate>Wed, 20 Mar 2019 14:15:59 +0800</pubDate>
      
      <guid>https://tangxusc.github.io/2019/03/golang%E6%97%A5%E5%BF%97%E5%BA%93/</guid>
      <description>&lt;p&gt;golang 标准库的日志框架非常简单，仅仅提供了 print，panic 和 fatal 三个函数对于更精细的日志级别、日志&lt;a href=&#34;https://www.baidu.com/s?wd=%E6%96%87%E4%BB%B6%E5%88%86%E5%89%B2&amp;amp;tn=24004469_oem_dg&amp;amp;rsv_dl=gh_pl_sl_csd&#34;&gt;文件分割&lt;/a&gt;以及日志分发等方面并没有提供支持。所以催生了很多第三方的日志库，但是在 golang 的世界里，没有一个日志库像 slf4j 那样在 Java 中具有绝对统治地位。golang 中，流行的日志框架包括 logrus、zap、zerolog、seelog 等。
logrus 是目前 Github 上 star 数量最多的日志库，目前 (2018.08，下同)star 数量为 8119，fork 数为 1031。logrus 功能强大，性能高效，而且具有高度灵活性，提供了自定义插件的功能。很多开源项目，如 docker，prometheus 等，都是用了 logrus 来记录其日志。
zap 是 &lt;a href=&#34;https://www.baidu.com/s?wd=Uber&amp;amp;tn=24004469_oem_dg&amp;amp;rsv_dl=gh_pl_sl_csd&#34;&gt;Uber&lt;/a&gt; 推出的一个快速、结构化的分级日志库。具有强大的 ad-hoc 分析功能，并且具有灵活的仪表盘。zap 目前在 GitHub 上的 star 数量约为 4.3k。
seelog 提供了灵活的异步调度、格式化和过滤功能。目前在 GitHub 上也有约 1.1k。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用 Golang 利用 ectd 实现一个分布式锁</title>
      <link>https://tangxusc.github.io/2019/03/%E4%BD%BF%E7%94%A8-golang-%E5%88%A9%E7%94%A8-ectd-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link>
      <pubDate>Wed, 20 Mar 2019 14:15:59 +0800</pubDate>
      
      <guid>https://tangxusc.github.io/2019/03/%E4%BD%BF%E7%94%A8-golang-%E5%88%A9%E7%94%A8-ectd-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid>
      <description>&lt;p&gt;&lt;code&gt;etcd&lt;/code&gt;是随着&lt;code&gt;CoreOS&lt;/code&gt;项目一起成长起来的，随着 Golang 和 CoreOS 等项目在开源社区日益火热， &lt;code&gt;etcd&lt;/code&gt;作为一个高可用、强一致性的分布式 Key-Value 存储系统被越来越多的开发人员关注和使用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用go mod(1.11)安装grpc</title>
      <link>https://tangxusc.github.io/2019/03/%E4%BD%BF%E7%94%A8go-mod1.11%E5%AE%89%E8%A3%85grpc/</link>
      <pubDate>Wed, 20 Mar 2019 14:15:59 +0800</pubDate>
      
      <guid>https://tangxusc.github.io/2019/03/%E4%BD%BF%E7%94%A8go-mod1.11%E5%AE%89%E8%A3%85grpc/</guid>
      <description>&lt;p&gt;使用go mod(1.11)安装grpc&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在golang中创建调用图</title>
      <link>https://tangxusc.github.io/2019/03/%E5%9C%A8golang%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%B0%83%E7%94%A8%E5%9B%BE/</link>
      <pubDate>Wed, 20 Mar 2019 14:15:59 +0800</pubDate>
      
      <guid>https://tangxusc.github.io/2019/03/%E5%9C%A8golang%E4%B8%AD%E5%88%9B%E5%BB%BA%E8%B0%83%E7%94%A8%E5%9B%BE/</guid>
      <description>&lt;p&gt;在golang中创建调用图&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>基于 go&#43;etcd 实现分布式锁</title>
      <link>https://tangxusc.github.io/2019/03/%E5%9F%BA%E4%BA%8E-go-etcd-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link>
      <pubDate>Wed, 20 Mar 2019 14:15:59 +0800</pubDate>
      
      <guid>https://tangxusc.github.io/2019/03/%E5%9F%BA%E4%BA%8E-go-etcd-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid>
      <description>&lt;p&gt;基于 go+etcd 实现分布式锁,主要使用的是租约机制&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何使用 go get 下载 gitlab 私有项目</title>
      <link>https://tangxusc.github.io/2019/03/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-go-get-%E4%B8%8B%E8%BD%BD-gitlab-%E7%A7%81%E6%9C%89%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Wed, 20 Mar 2019 14:15:59 +0800</pubDate>
      
      <guid>https://tangxusc.github.io/2019/03/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-go-get-%E4%B8%8B%E8%BD%BD-gitlab-%E7%A7%81%E6%9C%89%E9%A1%B9%E7%9B%AE/</guid>
      <description>&lt;p&gt;在我们使用golang开发项目时,会遇到私有仓库问题,本文章讲解golang中私有仓库的使用&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设置终端使用代理的几种方法</title>
      <link>https://tangxusc.github.io/2019/03/%E8%AE%BE%E7%BD%AE%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 20 Mar 2019 14:15:59 +0800</pubDate>
      
      <guid>https://tangxusc.github.io/2019/03/%E8%AE%BE%E7%BD%AE%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;p&gt;设置终端使用代理的几种方法&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>